<?php
/**
 * AuthenticationManagementApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * AuthenticationManagementApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AuthenticationManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsRealmAuthenticationAuthenticatorProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationConfigIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationConfigIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationConfigIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationConfigPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationExecutionsPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFlowsPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFormActionProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationFormProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationPerClientConfigDescriptionGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRegisterRequiredActionPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasPut' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationRequiredActionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsRealmAuthenticationAuthenticatorProvidersGet
     *
     * Get authenticator providers Returns a stream of authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function adminRealmsRealmAuthenticationAuthenticatorProvidersGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationAuthenticatorProvidersGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationAuthenticatorProvidersGetWithHttpInfo
     *
     * Get authenticator providers Returns a stream of authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationAuthenticatorProvidersGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationAuthenticatorProvidersGetAsync
     *
     * Get authenticator providers Returns a stream of authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationAuthenticatorProvidersGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationAuthenticatorProvidersGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationAuthenticatorProvidersGetAsyncWithHttpInfo
     *
     * Get authenticator providers Returns a stream of authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationAuthenticatorProvidersGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->adminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationAuthenticatorProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationAuthenticatorProvidersGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationAuthenticatorProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationAuthenticatorProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/authenticator-providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet
     *
     * Get client authenticator providers Returns a stream of client authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetWithHttpInfo
     *
     * Get client authenticator providers Returns a stream of client authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetAsync
     *
     * Get client authenticator providers Returns a stream of client authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetAsyncWithHttpInfo
     *
     * Get client authenticator providers Returns a stream of client authenticator providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationClientAuthenticatorProvidersGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationClientAuthenticatorProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/client-authenticator-providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet
     *
     * Get authenticator provider&#39;s configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $provider_id provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation
     */
    public function adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet($realm, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetWithHttpInfo($realm, $provider_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetWithHttpInfo
     *
     * Get authenticator provider&#39;s configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetWithHttpInfo($realm, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest($realm, $provider_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetAsync
     *
     * Get authenticator provider&#39;s configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetAsync($realm, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetAsyncWithHttpInfo($realm, $provider_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetAsyncWithHttpInfo
     *
     * Get authenticator provider&#39;s configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetAsyncWithHttpInfo($realm, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigInfoRepresentation';
        $request = $this->adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest($realm, $provider_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationConfigDescriptionProviderIdGetRequest($realm, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'
            );
        }

        // verify the required parameter 'provider_id' is set
        if ($provider_id === null || (is_array($provider_id) && count($provider_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_id when calling adminRealmsRealmAuthenticationConfigDescriptionProviderIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/config-description/{providerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($provider_id !== null) {
            $resourcePath = str_replace(
                '{' . 'providerId' . '}',
                ObjectSerializer::toPathValue($provider_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdDelete
     *
     * Delete authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationConfigIdDelete($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'][0])
    {
        $this->adminRealmsRealmAuthenticationConfigIdDeleteWithHttpInfo($realm, $id, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdDeleteWithHttpInfo
     *
     * Delete authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationConfigIdDeleteWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationConfigIdDeleteRequest($realm, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdDeleteAsync
     *
     * Delete authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdDeleteAsync($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'][0])
    {
        return $this->adminRealmsRealmAuthenticationConfigIdDeleteAsyncWithHttpInfo($realm, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdDeleteAsyncWithHttpInfo
     *
     * Delete authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdDeleteAsyncWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationConfigIdDeleteRequest($realm, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationConfigIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationConfigIdDeleteRequest($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationConfigIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationConfigIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/config/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdGet
     *
     * Get authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation
     */
    public function adminRealmsRealmAuthenticationConfigIdGet($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationConfigIdGetWithHttpInfo($realm, $id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdGetWithHttpInfo
     *
     * Get authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationConfigIdGetWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationConfigIdGetRequest($realm, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdGetAsync
     *
     * Get authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdGetAsync($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationConfigIdGetAsyncWithHttpInfo($realm, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdGetAsyncWithHttpInfo
     *
     * Get authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdGetAsyncWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation';
        $request = $this->adminRealmsRealmAuthenticationConfigIdGetRequest($realm, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationConfigIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationConfigIdGetRequest($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationConfigIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationConfigIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/config/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdPut
     *
     * Update authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationConfigIdPut($realm, $id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'][0])
    {
        $this->adminRealmsRealmAuthenticationConfigIdPutWithHttpInfo($realm, $id, $authenticator_config_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdPutWithHttpInfo
     *
     * Update authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationConfigIdPutWithHttpInfo($realm, $id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationConfigIdPutRequest($realm, $id, $authenticator_config_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdPutAsync
     *
     * Update authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdPutAsync($realm, $id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'][0])
    {
        return $this->adminRealmsRealmAuthenticationConfigIdPutAsyncWithHttpInfo($realm, $id, $authenticator_config_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigIdPutAsyncWithHttpInfo
     *
     * Update authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationConfigIdPutAsyncWithHttpInfo($realm, $id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationConfigIdPutRequest($realm, $id, $authenticator_config_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationConfigIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Configuration id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationConfigIdPutRequest($realm, $id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationConfigIdPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationConfigIdPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/config/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authenticator_config_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authenticator_config_representation));
            } else {
                $httpBody = $authenticator_config_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigPost
     *
     * Create new authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationConfigPost($realm, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigPost'][0])
    {
        $this->adminRealmsRealmAuthenticationConfigPostWithHttpInfo($realm, $authenticator_config_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigPostWithHttpInfo
     *
     * Create new authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationConfigPostWithHttpInfo($realm, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationConfigPostRequest($realm, $authenticator_config_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigPostAsync
     *
     * Create new authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationConfigPostAsync($realm, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationConfigPostAsyncWithHttpInfo($realm, $authenticator_config_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationConfigPostAsyncWithHttpInfo
     *
     * Create new authenticator configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationConfigPostAsyncWithHttpInfo($realm, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationConfigPostRequest($realm, $authenticator_config_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationConfigPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationConfigPostRequest($realm, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationConfigPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationConfigPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authenticator_config_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authenticator_config_representation));
            } else {
                $httpBody = $authenticator_config_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet
     *
     * Get execution&#39;s configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet($realm, $execution_id, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetWithHttpInfo($realm, $execution_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetWithHttpInfo
     *
     * Get execution&#39;s configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetWithHttpInfo($realm, $execution_id, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest($realm, $execution_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetAsync
     *
     * Get execution&#39;s configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetAsync($realm, $execution_id, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetAsyncWithHttpInfo($realm, $execution_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetAsyncWithHttpInfo
     *
     * Get execution&#39;s configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetAsyncWithHttpInfo($realm, $execution_id, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest($realm, $execution_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $id Configuration id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGetRequest($realm, $execution_id, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdConfigIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}/config/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost
     *
     * Update execution with new configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost($realm, $execution_id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'][0])
    {
        $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostWithHttpInfo($realm, $execution_id, $authenticator_config_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostWithHttpInfo
     *
     * Update execution with new configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostWithHttpInfo($realm, $execution_id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest($realm, $execution_id, $authenticator_config_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostAsync
     *
     * Update execution with new configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostAsync($realm, $execution_id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostAsyncWithHttpInfo($realm, $execution_id, $authenticator_config_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostAsyncWithHttpInfo
     *
     * Update execution with new configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostAsyncWithHttpInfo($realm, $execution_id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest($realm, $execution_id, $authenticator_config_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticatorConfigRepresentation $authenticator_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPostRequest($realm, $execution_id, $authenticator_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdConfigPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authenticator_config_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authenticator_config_representation));
            } else {
                $httpBody = $authenticator_config_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdDelete
     *
     * Delete execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdDelete($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'][0])
    {
        $this->adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteWithHttpInfo($realm, $execution_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteWithHttpInfo
     *
     * Delete execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest($realm, $execution_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteAsync
     *
     * Delete execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteAsync($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteAsyncWithHttpInfo($realm, $execution_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteAsyncWithHttpInfo
     *
     * Delete execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteAsyncWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest($realm, $execution_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdDeleteRequest($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdGet
     *
     * Get Single Execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id execution_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdGet($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdGetWithHttpInfo($realm, $execution_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdGetWithHttpInfo
     *
     * Get Single Execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdGetWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest($realm, $execution_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdGetAsync
     *
     * Get Single Execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdGetAsync($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdGetAsyncWithHttpInfo($realm, $execution_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdGetAsyncWithHttpInfo
     *
     * Get Single Execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdGetAsyncWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest($realm, $execution_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdGetRequest($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdGet'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost
     *
     * Lower execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'][0])
    {
        $this->adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostWithHttpInfo($realm, $execution_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostWithHttpInfo
     *
     * Lower execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest($realm, $execution_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostAsync
     *
     * Lower execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostAsync($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostAsyncWithHttpInfo($realm, $execution_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostAsyncWithHttpInfo
     *
     * Lower execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostAsyncWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest($realm, $execution_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPostRequest($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdLowerPriorityPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}/lower-priority';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost
     *
     * Raise execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'][0])
    {
        $this->adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostWithHttpInfo($realm, $execution_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostWithHttpInfo
     *
     * Raise execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest($realm, $execution_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostAsync
     *
     * Raise execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostAsync($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostAsyncWithHttpInfo($realm, $execution_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostAsyncWithHttpInfo
     *
     * Raise execution&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostAsyncWithHttpInfo($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest($realm, $execution_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $execution_id Execution id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPostRequest($realm, $execution_id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'
            );
        }

        // verify the required parameter 'execution_id' is set
        if ($execution_id === null || (is_array($execution_id) && count($execution_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $execution_id when calling adminRealmsRealmAuthenticationExecutionsExecutionIdRaisePriorityPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/executions/{executionId}/raise-priority';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($execution_id !== null) {
            $resourcePath = str_replace(
                '{' . 'executionId' . '}',
                ObjectSerializer::toPathValue($execution_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsPost
     *
     * Add new authentication execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation $authentication_execution_representation authentication_execution_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationExecutionsPost($realm, $authentication_execution_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'][0])
    {
        $this->adminRealmsRealmAuthenticationExecutionsPostWithHttpInfo($realm, $authentication_execution_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsPostWithHttpInfo
     *
     * Add new authentication execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation $authentication_execution_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationExecutionsPostWithHttpInfo($realm, $authentication_execution_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationExecutionsPostRequest($realm, $authentication_execution_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsPostAsync
     *
     * Add new authentication execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation $authentication_execution_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsPostAsync($realm, $authentication_execution_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationExecutionsPostAsyncWithHttpInfo($realm, $authentication_execution_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationExecutionsPostAsyncWithHttpInfo
     *
     * Add new authentication execution
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation $authentication_execution_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationExecutionsPostAsyncWithHttpInfo($realm, $authentication_execution_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationExecutionsPostRequest($realm, $authentication_execution_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationExecutionsPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionRepresentation $authentication_execution_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationExecutionsPostRequest($realm, $authentication_execution_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationExecutionsPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationExecutionsPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/executions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authentication_execution_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authentication_execution_representation));
            } else {
                $httpBody = $authentication_execution_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost
     *
     * Copy existing authentication flow under a new name The new name is given as &#39;newName&#39; attribute of the passed JSON object
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias name of the existing authentication flow (required)
     * @param  array<string,string> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostWithHttpInfo($realm, $flow_alias, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostWithHttpInfo
     *
     * Copy existing authentication flow under a new name The new name is given as &#39;newName&#39; attribute of the passed JSON object
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias name of the existing authentication flow (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest($realm, $flow_alias, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostAsync
     *
     * Copy existing authentication flow under a new name The new name is given as &#39;newName&#39; attribute of the passed JSON object
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias name of the existing authentication flow (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostAsync($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostAsyncWithHttpInfo($realm, $flow_alias, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostAsyncWithHttpInfo
     *
     * Copy existing authentication flow under a new name The new name is given as &#39;newName&#39; attribute of the passed JSON object
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias name of the existing authentication flow (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostAsyncWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest($realm, $flow_alias, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias name of the existing authentication flow (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasCopyPostRequest($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'
            );
        }

        // verify the required parameter 'flow_alias' is set
        if ($flow_alias === null || (is_array($flow_alias) && count($flow_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_alias when calling adminRealmsRealmAuthenticationFlowsFlowAliasCopyPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows/{flowAlias}/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($flow_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'flowAlias' . '}',
                ObjectSerializer::toPathValue($flow_alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost
     *
     * Add new authentication execution to a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent flow (required)
     * @param  array<string,mixed> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostWithHttpInfo($realm, $flow_alias, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostWithHttpInfo
     *
     * Add new authentication execution to a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest($realm, $flow_alias, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostAsync
     *
     * Add new authentication execution to a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostAsync($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostAsyncWithHttpInfo($realm, $flow_alias, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostAsyncWithHttpInfo
     *
     * Add new authentication execution to a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostAsyncWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest($realm, $flow_alias, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPostRequest($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'
            );
        }

        // verify the required parameter 'flow_alias' is set
        if ($flow_alias === null || (is_array($flow_alias) && count($flow_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_alias when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsExecutionPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/execution';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($flow_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'flowAlias' . '}',
                ObjectSerializer::toPathValue($flow_alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost
     *
     * Add new flow with new execution to existing flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent authentication flow (required)
     * @param  array<string,mixed> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostWithHttpInfo($realm, $flow_alias, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostWithHttpInfo
     *
     * Add new flow with new execution to existing flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent authentication flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest($realm, $flow_alias, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostAsync
     *
     * Add new flow with new execution to existing flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent authentication flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostAsync($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostAsyncWithHttpInfo($realm, $flow_alias, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostAsyncWithHttpInfo
     *
     * Add new flow with new execution to existing flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent authentication flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostAsyncWithHttpInfo($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest($realm, $flow_alias, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Alias of parent authentication flow (required)
     * @param  array<string,mixed> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPostRequest($realm, $flow_alias, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'
            );
        }

        // verify the required parameter 'flow_alias' is set
        if ($flow_alias === null || (is_array($flow_alias) && count($flow_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_alias when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsFlowPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows/{flowAlias}/executions/flow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($flow_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'flowAlias' . '}',
                ObjectSerializer::toPathValue($flow_alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet
     *
     * Get authentication executions for a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet($realm, $flow_alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetWithHttpInfo($realm, $flow_alias, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetWithHttpInfo
     *
     * Get authentication executions for a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetWithHttpInfo($realm, $flow_alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest($realm, $flow_alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetAsync
     *
     * Get authentication executions for a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetAsync($realm, $flow_alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetAsyncWithHttpInfo($realm, $flow_alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetAsyncWithHttpInfo
     *
     * Get authentication executions for a flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetAsyncWithHttpInfo($realm, $flow_alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation[]';
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest($realm, $flow_alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGetRequest($realm, $flow_alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'
            );
        }

        // verify the required parameter 'flow_alias' is set
        if ($flow_alias === null || (is_array($flow_alias) && count($flow_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_alias when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/flows/{flowAlias}/executions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($flow_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'flowAlias' . '}',
                ObjectSerializer::toPathValue($flow_alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut
     *
     * Update authentication executions of a Flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation $authentication_execution_info_representation authentication_execution_info_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut($realm, $flow_alias, $authentication_execution_info_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutWithHttpInfo($realm, $flow_alias, $authentication_execution_info_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutWithHttpInfo
     *
     * Update authentication executions of a Flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation $authentication_execution_info_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutWithHttpInfo($realm, $flow_alias, $authentication_execution_info_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest($realm, $flow_alias, $authentication_execution_info_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutAsync
     *
     * Update authentication executions of a Flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation $authentication_execution_info_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutAsync($realm, $flow_alias, $authentication_execution_info_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutAsyncWithHttpInfo($realm, $flow_alias, $authentication_execution_info_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutAsyncWithHttpInfo
     *
     * Update authentication executions of a Flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation $authentication_execution_info_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutAsyncWithHttpInfo($realm, $flow_alias, $authentication_execution_info_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest($realm, $flow_alias, $authentication_execution_info_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $flow_alias Flow alias (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationExecutionInfoRepresentation $authentication_execution_info_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPutRequest($realm, $flow_alias, $authentication_execution_info_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'
            );
        }

        // verify the required parameter 'flow_alias' is set
        if ($flow_alias === null || (is_array($flow_alias) && count($flow_alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $flow_alias when calling adminRealmsRealmAuthenticationFlowsFlowAliasExecutionsPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows/{flowAlias}/executions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($flow_alias !== null) {
            $resourcePath = str_replace(
                '{' . 'flowAlias' . '}',
                ObjectSerializer::toPathValue($flow_alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authentication_execution_info_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authentication_execution_info_representation));
            } else {
                $httpBody = $authentication_execution_info_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsGet
     *
     * Get authentication flows Returns a stream of authentication flows.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]
     */
    public function adminRealmsRealmAuthenticationFlowsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationFlowsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsGetWithHttpInfo
     *
     * Get authentication flows Returns a stream of authentication flows.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsGetAsync
     *
     * Get authentication flows Returns a stream of authentication flows.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsGetAsyncWithHttpInfo
     *
     * Get authentication flows Returns a stream of authentication flows.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation[]';
        $request = $this->adminRealmsRealmAuthenticationFlowsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/flows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdDelete
     *
     * Delete an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsIdDelete($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsIdDeleteWithHttpInfo($realm, $id, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdDeleteWithHttpInfo
     *
     * Delete an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsIdDeleteWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsIdDeleteRequest($realm, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdDeleteAsync
     *
     * Delete an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdDeleteAsync($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsIdDeleteAsyncWithHttpInfo($realm, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdDeleteAsyncWithHttpInfo
     *
     * Delete an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdDeleteAsyncWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsIdDeleteRequest($realm, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsIdDeleteRequest($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsIdDelete'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationFlowsIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/flows/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdGet
     *
     * Get authentication flow for id
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation
     */
    public function adminRealmsRealmAuthenticationFlowsIdGet($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationFlowsIdGetWithHttpInfo($realm, $id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdGetWithHttpInfo
     *
     * Get authentication flow for id
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsIdGetWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsIdGetRequest($realm, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdGetAsync
     *
     * Get authentication flow for id
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdGetAsync($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsIdGetAsyncWithHttpInfo($realm, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdGetAsyncWithHttpInfo
     *
     * Get authentication flow for id
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdGetAsyncWithHttpInfo($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation';
        $request = $this->adminRealmsRealmAuthenticationFlowsIdGetRequest($realm, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id Flow id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsIdGetRequest($realm, $id, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsIdGet'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationFlowsIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/flows/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdPut
     *
     * Update an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsIdPut($realm, $id, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsIdPutWithHttpInfo($realm, $id, $authentication_flow_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdPutWithHttpInfo
     *
     * Update an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsIdPutWithHttpInfo($realm, $id, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsIdPutRequest($realm, $id, $authentication_flow_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdPutAsync
     *
     * Update an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdPutAsync($realm, $id, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsIdPutAsyncWithHttpInfo($realm, $id, $authentication_flow_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsIdPutAsyncWithHttpInfo
     *
     * Update an authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsIdPutAsyncWithHttpInfo($realm, $id, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsIdPutRequest($realm, $id, $authentication_flow_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsIdPutRequest($realm, $id, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsIdPut'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling adminRealmsRealmAuthenticationFlowsIdPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authentication_flow_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authentication_flow_representation));
            } else {
                $httpBody = $authentication_flow_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsPost
     *
     * Create a new authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationFlowsPost($realm, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'][0])
    {
        $this->adminRealmsRealmAuthenticationFlowsPostWithHttpInfo($realm, $authentication_flow_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsPostWithHttpInfo
     *
     * Create a new authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFlowsPostWithHttpInfo($realm, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFlowsPostRequest($realm, $authentication_flow_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsPostAsync
     *
     * Create a new authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsPostAsync($realm, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationFlowsPostAsyncWithHttpInfo($realm, $authentication_flow_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFlowsPostAsyncWithHttpInfo
     *
     * Create a new authentication flow
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFlowsPostAsyncWithHttpInfo($realm, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationFlowsPostRequest($realm, $authentication_flow_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFlowsPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\AuthenticationFlowRepresentation $authentication_flow_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFlowsPostRequest($realm, $authentication_flow_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFlowsPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFlowsPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/flows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($authentication_flow_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($authentication_flow_representation));
            } else {
                $httpBody = $authentication_flow_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormActionProvidersGet
     *
     * Get form action providers Returns a stream of form action providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function adminRealmsRealmAuthenticationFormActionProvidersGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationFormActionProvidersGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormActionProvidersGetWithHttpInfo
     *
     * Get form action providers Returns a stream of form action providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFormActionProvidersGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFormActionProvidersGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormActionProvidersGetAsync
     *
     * Get form action providers Returns a stream of form action providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFormActionProvidersGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationFormActionProvidersGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormActionProvidersGetAsyncWithHttpInfo
     *
     * Get form action providers Returns a stream of form action providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFormActionProvidersGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->adminRealmsRealmAuthenticationFormActionProvidersGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFormActionProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFormActionProvidersGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormActionProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFormActionProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/form-action-providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormProvidersGet
     *
     * Get form providers Returns a stream of form providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function adminRealmsRealmAuthenticationFormProvidersGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationFormProvidersGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormProvidersGetWithHttpInfo
     *
     * Get form providers Returns a stream of form providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationFormProvidersGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationFormProvidersGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormProvidersGetAsync
     *
     * Get form providers Returns a stream of form providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFormProvidersGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationFormProvidersGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationFormProvidersGetAsyncWithHttpInfo
     *
     * Get form providers Returns a stream of form providers.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationFormProvidersGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->adminRealmsRealmAuthenticationFormProvidersGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationFormProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationFormProvidersGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationFormProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationFormProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/form-providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationPerClientConfigDescriptionGet
     *
     * Get configuration descriptions for all clients
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>
     */
    public function adminRealmsRealmAuthenticationPerClientConfigDescriptionGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationPerClientConfigDescriptionGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationPerClientConfigDescriptionGetWithHttpInfo
     *
     * Get configuration descriptions for all clients
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationPerClientConfigDescriptionGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationPerClientConfigDescriptionGetAsync
     *
     * Get configuration descriptions for all clients
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationPerClientConfigDescriptionGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationPerClientConfigDescriptionGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationPerClientConfigDescriptionGetAsyncWithHttpInfo
     *
     * Get configuration descriptions for all clients
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationPerClientConfigDescriptionGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'][0])
    {
        $returnType = 'array<string,\WebMI\KeycloakApiClient\KeycloakApi\Model\ConfigPropertyRepresentation[]>';
        $request = $this->adminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationPerClientConfigDescriptionGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationPerClientConfigDescriptionGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/per-client-config-description';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRegisterRequiredActionPost
     *
     * Register a new required actions
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRegisterRequiredActionPost($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'][0])
    {
        $this->adminRealmsRealmAuthenticationRegisterRequiredActionPostWithHttpInfo($realm, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRegisterRequiredActionPostWithHttpInfo
     *
     * Register a new required actions
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRegisterRequiredActionPostWithHttpInfo($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRegisterRequiredActionPostRequest($realm, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRegisterRequiredActionPostAsync
     *
     * Register a new required actions
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRegisterRequiredActionPostAsync($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationRegisterRequiredActionPostAsyncWithHttpInfo($realm, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRegisterRequiredActionPostAsyncWithHttpInfo
     *
     * Register a new required actions
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRegisterRequiredActionPostAsyncWithHttpInfo($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRegisterRequiredActionPostRequest($realm, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRegisterRequiredActionPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRegisterRequiredActionPostRequest($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRegisterRequiredActionPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRegisterRequiredActionPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/register-required-action';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete
     *
     * Delete RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteWithHttpInfo($realm, $alias, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteWithHttpInfo
     *
     * Delete RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteAsync
     *
     * Delete RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteAsyncWithHttpInfo
     *
     * Delete RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDeleteRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet
     *
     * Get RequiredAction provider configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetWithHttpInfo($realm, $alias, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetWithHttpInfo
     *
     * Get RequiredAction provider configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetAsync
     *
     * Get RequiredAction provider configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetAsyncWithHttpInfo
     *
     * Get RequiredAction provider configuration description
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigInfoRepresentation';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGetRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigDescriptionGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/config-description';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet
     *
     * Get RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetWithHttpInfo($realm, $alias, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetWithHttpInfo
     *
     * Get RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetAsync
     *
     * Get RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetAsyncWithHttpInfo
     *
     * Get RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigGetRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut
     *
     * Update RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation $required_action_config_representation required_action_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut($realm, $alias, $required_action_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutWithHttpInfo($realm, $alias, $required_action_config_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutWithHttpInfo
     *
     * Update RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation $required_action_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutWithHttpInfo($realm, $alias, $required_action_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutRequest($realm, $alias, $required_action_config_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutAsync
     *
     * Update RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation $required_action_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutAsync($realm, $alias, $required_action_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutAsyncWithHttpInfo($realm, $alias, $required_action_config_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutAsyncWithHttpInfo
     *
     * Update RequiredAction configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation $required_action_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutAsyncWithHttpInfo($realm, $alias, $required_action_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutRequest($realm, $alias, $required_action_config_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionConfigRepresentation $required_action_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasConfigPutRequest($realm, $alias, $required_action_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasConfigPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($required_action_config_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($required_action_config_representation));
            } else {
                $httpBody = $required_action_config_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasDelete
     *
     * Delete required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasDelete($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasDeleteWithHttpInfo($realm, $alias, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasDeleteWithHttpInfo
     *
     * Delete required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasDeleteWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasDeleteAsync
     *
     * Delete required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasDeleteAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasDeleteAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasDeleteAsyncWithHttpInfo
     *
     * Delete required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasDeleteAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasDeleteRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasDelete'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasGet
     *
     * Get required action for alias
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasGet($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationRequiredActionsAliasGetWithHttpInfo($realm, $alias, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasGetWithHttpInfo
     *
     * Get required action for alias
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasGetWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasGetRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasGetAsync
     *
     * Get required action for alias
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasGetAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasGetAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasGetAsyncWithHttpInfo
     *
     * Get required action for alias
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasGetAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasGetRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasGetRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasGet'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost
     *
     * Lower required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostWithHttpInfo($realm, $alias, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostWithHttpInfo
     *
     * Lower required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostAsync
     *
     * Lower required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostAsyncWithHttpInfo
     *
     * Lower required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPostRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasLowerPriorityPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/lower-priority';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasPut
     *
     * Update required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation $required_action_provider_representation required_action_provider_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasPut($realm, $alias, $required_action_provider_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasPutWithHttpInfo($realm, $alias, $required_action_provider_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasPutWithHttpInfo
     *
     * Update required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation $required_action_provider_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasPutWithHttpInfo($realm, $alias, $required_action_provider_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasPutRequest($realm, $alias, $required_action_provider_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasPutAsync
     *
     * Update required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation $required_action_provider_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasPutAsync($realm, $alias, $required_action_provider_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasPutAsyncWithHttpInfo($realm, $alias, $required_action_provider_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasPutAsyncWithHttpInfo
     *
     * Update required action
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation $required_action_provider_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasPutAsyncWithHttpInfo($realm, $alias, $required_action_provider_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasPutRequest($realm, $alias, $required_action_provider_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation $required_action_provider_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasPutRequest($realm, $alias, $required_action_provider_representation = null, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasPut'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($required_action_provider_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($required_action_provider_representation));
            } else {
                $httpBody = $required_action_provider_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost
     *
     * Raise required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'][0])
    {
        $this->adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostWithHttpInfo($realm, $alias, $contentType);
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostWithHttpInfo
     *
     * Raise required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest($realm, $alias, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostAsync
     *
     * Raise required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostAsync($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostAsyncWithHttpInfo($realm, $alias, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostAsyncWithHttpInfo
     *
     * Raise required action&#39;s priority
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostAsyncWithHttpInfo($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest($realm, $alias, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $alias Alias of required action (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPostRequest($realm, $alias, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'
            );
        }

        // verify the required parameter 'alias' is set
        if ($alias === null || (is_array($alias) && count($alias) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $alias when calling adminRealmsRealmAuthenticationRequiredActionsAliasRaisePriorityPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions/{alias}/raise-priority';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($alias !== null) {
            $resourcePath = str_replace(
                '{' . 'alias' . '}',
                ObjectSerializer::toPathValue($alias),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsGet
     *
     * Get required actions Returns a stream of required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]
     */
    public function adminRealmsRealmAuthenticationRequiredActionsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationRequiredActionsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsGetWithHttpInfo
     *
     * Get required actions Returns a stream of required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationRequiredActionsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsGetAsync
     *
     * Get required actions Returns a stream of required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationRequiredActionsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationRequiredActionsGetAsyncWithHttpInfo
     *
     * Get required actions Returns a stream of required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationRequiredActionsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RequiredActionProviderRepresentation[]';
        $request = $this->adminRealmsRealmAuthenticationRequiredActionsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationRequiredActionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationRequiredActionsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationRequiredActionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationRequiredActionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/required-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet
     *
     * Get unregistered required actions Returns a stream of unregistered required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string>[]
     */
    public function adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetWithHttpInfo
     *
     * Get unregistered required actions Returns a stream of unregistered required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'][0])
    {
        $request = $this->adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,string>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,string>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetAsync
     *
     * Get unregistered required actions Returns a stream of unregistered required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'][0])
    {
        return $this->adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetAsyncWithHttpInfo
     *
     * Get unregistered required actions Returns a stream of unregistered required actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'][0])
    {
        $returnType = 'array<string,string>[]';
        $request = $this->adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAuthenticationUnregisteredRequiredActionsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAuthenticationUnregisteredRequiredActionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/authentication/unregistered-required-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
