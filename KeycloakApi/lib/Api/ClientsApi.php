<?php
/**
 * ClientsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * ClientsApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ClientsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsRealmClientsClientUuidClientSecretGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidClientSecretPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidClientSecretRotatedDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidClientSecretRotatedGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidDefaultClientScopesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidManagementPermissionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidManagementPermissionsPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidNodesNodeDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidNodesPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidOfflineSessionCountGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidOfflineSessionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidOptionalClientScopesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidPushRevocationPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidServiceAccountUserGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidSessionCountGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidTestNodesAvailableGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidUserSessionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsPost' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretGet
     *
     * Get the client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation
     */
    public function adminRealmsRealmClientsClientUuidClientSecretGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidClientSecretGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretGetWithHttpInfo
     *
     * Get the client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidClientSecretGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretGetAsync
     *
     * Get the client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidClientSecretGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretGetAsyncWithHttpInfo
     *
     * Get the client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidClientSecretGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidClientSecretGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidClientSecretGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidClientSecretGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/client-secret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretPost
     *
     * Generate a new secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation
     */
    public function adminRealmsRealmClientsClientUuidClientSecretPost($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidClientSecretPostWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretPostWithHttpInfo
     *
     * Generate a new secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidClientSecretPostWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretPostRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretPostAsync
     *
     * Generate a new secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretPostAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidClientSecretPostAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretPostAsyncWithHttpInfo
     *
     * Generate a new secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretPostAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretPostRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidClientSecretPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidClientSecretPostRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidClientSecretPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidClientSecretPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/client-secret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedDelete
     *
     * Invalidate the rotated secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedDelete($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteWithHttpInfo($realm, $client_uuid, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteWithHttpInfo
     *
     * Invalidate the rotated secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteAsync
     *
     * Invalidate the rotated secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteAsyncWithHttpInfo
     *
     * Invalidate the rotated secret for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedDeleteRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidClientSecretRotatedDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedGet
     *
     * Get the rotated client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidClientSecretRotatedGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedGetWithHttpInfo
     *
     * Get the rotated client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedGetAsync
     *
     * Get the rotated client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidClientSecretRotatedGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidClientSecretRotatedGetAsyncWithHttpInfo
     *
     * Get the rotated client secret
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidClientSecretRotatedGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidClientSecretRotatedGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidClientSecretRotatedGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidClientSecretRotatedGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidClientSecretRotatedGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/client-secret/rotated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteAsync($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutAsync($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmClientsClientUuidDefaultClientScopesClientScopeIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesGet
     *
     * Get default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesGetWithHttpInfo
     *
     * Get default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesGetAsync
     *
     * Get default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidDefaultClientScopesGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDefaultClientScopesGetAsyncWithHttpInfo
     *
     * Get default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidDefaultClientScopesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidDefaultClientScopesGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDefaultClientScopesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidDefaultClientScopesGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidDefaultClientScopesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/default-client-scopes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDelete
     *
     * Delete the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidDelete($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidDeleteWithHttpInfo($realm, $client_uuid, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDeleteWithHttpInfo
     *
     * Delete the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidDeleteWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidDeleteRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDeleteAsync
     *
     * Delete the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDeleteAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidDeleteAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidDeleteAsyncWithHttpInfo
     *
     * Delete the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidDeleteAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidDeleteRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidDeleteRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet
     *
     * Create JSON with payload of example access token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope scope (optional)
     * @param  string $user_id user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetWithHttpInfo
     *
     * Create JSON with payload of example access token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetAsync
     *
     * Create JSON with payload of example access token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetAsync($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetAsyncWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetAsyncWithHttpInfo
     *
     * Create JSON with payload of example access token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetAsyncWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AccessToken';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGetRequest($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleAccessTokenGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-access-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet
     *
     * Create JSON with payload of example id token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope scope (optional)
     * @param  string $user_id user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetWithHttpInfo
     *
     * Create JSON with payload of example id token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetAsync
     *
     * Create JSON with payload of example id token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetAsync($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetAsyncWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetAsyncWithHttpInfo
     *
     * Create JSON with payload of example id token
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetAsyncWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\IDToken';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGetRequest($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleIdTokenGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-id-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet
     *
     * Create JSON with payload of example user info
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope scope (optional)
     * @param  string $user_id user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetWithHttpInfo
     *
     * Create JSON with payload of example user info
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetAsync
     *
     * Create JSON with payload of example user info
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetAsync($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetAsyncWithHttpInfo($realm, $client_uuid, $scope, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetAsyncWithHttpInfo
     *
     * Create JSON with payload of example user info
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetAsyncWithHttpInfo($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'][0])
    {
        $returnType = 'array<string,mixed>';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest($realm, $client_uuid, $scope, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $user_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGetRequest($realm, $client_uuid, $scope = null, $user_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesGenerateExampleUserinfoGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/generate-example-userinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'userId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet
     *
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet($realm, $client_uuid, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetWithHttpInfo($realm, $client_uuid, $scope, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetWithHttpInfo
     *
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetWithHttpInfo($realm, $client_uuid, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest($realm, $client_uuid, $scope, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetAsync
     *
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetAsync($realm, $client_uuid, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetAsyncWithHttpInfo($realm, $client_uuid, $scope, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetAsyncWithHttpInfo
     *
     * Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetAsyncWithHttpInfo($realm, $client_uuid, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ProtocolMapperEvaluationRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest($realm, $client_uuid, $scope, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGetRequest($realm, $client_uuid, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesProtocolMappersGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/protocol-mappers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet
     *
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetWithHttpInfo($realm, $client_uuid, $role_container_id, $scope, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetWithHttpInfo
     *
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetWithHttpInfo($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetAsync
     *
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetAsync($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetAsyncWithHttpInfo($realm, $client_uuid, $role_container_id, $scope, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetAsyncWithHttpInfo
     *
     * Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetAsyncWithHttpInfo($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'
            );
        }

        // verify the required parameter 'role_container_id' is set
        if ($role_container_id === null || (is_array($role_container_id) && count($role_container_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_container_id when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdGrantedGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/granted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($role_container_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roleContainerId' . '}',
                ObjectSerializer::toPathValue($role_container_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet
     *
     * Get roles, which this client doesn&#39;t have scope for and can&#39;t have them in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetWithHttpInfo($realm, $client_uuid, $role_container_id, $scope, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetWithHttpInfo
     *
     * Get roles, which this client doesn&#39;t have scope for and can&#39;t have them in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetWithHttpInfo($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetAsync
     *
     * Get roles, which this client doesn&#39;t have scope for and can&#39;t have them in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetAsync($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetAsyncWithHttpInfo($realm, $client_uuid, $role_container_id, $scope, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetAsyncWithHttpInfo
     *
     * Get roles, which this client doesn&#39;t have scope for and can&#39;t have them in the accessToken issued for him.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetAsyncWithHttpInfo($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RoleRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $role_container_id either realm name OR client UUID (required)
     * @param  string $scope (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGetRequest($realm, $client_uuid, $role_container_id, $scope = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'
            );
        }

        // verify the required parameter 'role_container_id' is set
        if ($role_container_id === null || (is_array($role_container_id) && count($role_container_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_container_id when calling adminRealmsRealmClientsClientUuidEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/evaluate-scopes/scope-mappings/{roleContainerId}/not-granted';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($role_container_id !== null) {
            $resourcePath = str_replace(
                '{' . 'roleContainerId' . '}',
                ObjectSerializer::toPathValue($role_container_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidGet
     *
     * Get representation of the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation
     */
    public function adminRealmsRealmClientsClientUuidGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidGetWithHttpInfo
     *
     * Get representation of the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidGetAsync
     *
     * Get representation of the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidGetAsyncWithHttpInfo
     *
     * Get representation of the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $provider_id provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet($realm, $client_uuid, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'][0])
    {
        $this->adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetWithHttpInfo($realm, $client_uuid, $provider_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetWithHttpInfo($realm, $client_uuid, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest($realm, $client_uuid, $provider_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetAsync($realm, $client_uuid, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetAsyncWithHttpInfo($realm, $client_uuid, $provider_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetAsyncWithHttpInfo($realm, $client_uuid, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest($realm, $client_uuid, $provider_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $provider_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGetRequest($realm, $client_uuid, $provider_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'
            );
        }

        // verify the required parameter 'provider_id' is set
        if ($provider_id === null || (is_array($provider_id) && count($provider_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider_id when calling adminRealmsRealmClientsClientUuidInstallationProvidersProviderIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/installation/providers/{providerId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($provider_id !== null) {
            $resourcePath = str_replace(
                '{' . 'providerId' . '}',
                ObjectSerializer::toPathValue($provider_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsGet
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidManagementPermissionsGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsGetWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidManagementPermissionsGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsGetAsync
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidManagementPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsGetAsyncWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmClientsClientUuidManagementPermissionsGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidManagementPermissionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidManagementPermissionsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidManagementPermissionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/management/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsPut
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsPut($realm, $client_uuid, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidManagementPermissionsPutWithHttpInfo($realm, $client_uuid, $management_permission_reference, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsPutWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsPutWithHttpInfo($realm, $client_uuid, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidManagementPermissionsPutRequest($realm, $client_uuid, $management_permission_reference, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsPutAsync
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsPutAsync($realm, $client_uuid, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidManagementPermissionsPutAsyncWithHttpInfo($realm, $client_uuid, $management_permission_reference, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidManagementPermissionsPutAsyncWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsPutAsyncWithHttpInfo($realm, $client_uuid, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmClientsClientUuidManagementPermissionsPutRequest($realm, $client_uuid, $management_permission_reference, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidManagementPermissionsPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidManagementPermissionsPutRequest($realm, $client_uuid, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidManagementPermissionsPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidManagementPermissionsPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidManagementPermissionsPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/management/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($management_permission_reference)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($management_permission_reference));
            } else {
                $httpBody = $management_permission_reference;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesNodeDelete
     *
     * Unregister a cluster node from the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $node node (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidNodesNodeDelete($realm, $client_uuid, $node, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidNodesNodeDeleteWithHttpInfo($realm, $client_uuid, $node, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesNodeDeleteWithHttpInfo
     *
     * Unregister a cluster node from the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $node (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidNodesNodeDeleteWithHttpInfo($realm, $client_uuid, $node, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidNodesNodeDeleteRequest($realm, $client_uuid, $node, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesNodeDeleteAsync
     *
     * Unregister a cluster node from the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $node (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidNodesNodeDeleteAsync($realm, $client_uuid, $node, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidNodesNodeDeleteAsyncWithHttpInfo($realm, $client_uuid, $node, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesNodeDeleteAsyncWithHttpInfo
     *
     * Unregister a cluster node from the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $node (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidNodesNodeDeleteAsyncWithHttpInfo($realm, $client_uuid, $node, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidNodesNodeDeleteRequest($realm, $client_uuid, $node, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidNodesNodeDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $node (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidNodesNodeDeleteRequest($realm, $client_uuid, $node, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesNodeDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidNodesNodeDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidNodesNodeDelete'
            );
        }

        // verify the required parameter 'node' is set
        if ($node === null || (is_array($node) && count($node) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $node when calling adminRealmsRealmClientsClientUuidNodesNodeDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/nodes/{node}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($node !== null) {
            $resourcePath = str_replace(
                '{' . 'node' . '}',
                ObjectSerializer::toPathValue($node),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesPost
     *
     * Register a cluster node with the client Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle by sending registration request to Keycloak
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  array<string,string> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidNodesPost($realm, $client_uuid, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'][0])
    {
        $this->adminRealmsRealmClientsClientUuidNodesPostWithHttpInfo($realm, $client_uuid, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesPostWithHttpInfo
     *
     * Register a cluster node with the client Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle by sending registration request to Keycloak
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidNodesPostWithHttpInfo($realm, $client_uuid, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidNodesPostRequest($realm, $client_uuid, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesPostAsync
     *
     * Register a cluster node with the client Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle by sending registration request to Keycloak
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidNodesPostAsync($realm, $client_uuid, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidNodesPostAsyncWithHttpInfo($realm, $client_uuid, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidNodesPostAsyncWithHttpInfo
     *
     * Register a cluster node with the client Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle by sending registration request to Keycloak
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidNodesPostAsyncWithHttpInfo($realm, $client_uuid, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidNodesPostRequest($realm, $client_uuid, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidNodesPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidNodesPostRequest($realm, $client_uuid, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidNodesPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidNodesPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidNodesPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionCountGet
     *
     * Get application offline session count Returns a number of offline user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,int>
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionCountGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidOfflineSessionCountGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionCountGetWithHttpInfo
     *
     * Get application offline session count Returns a number of offline user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,int>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionCountGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,int>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,int>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,int>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,int>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,int>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionCountGetAsync
     *
     * Get application offline session count Returns a number of offline user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionCountGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidOfflineSessionCountGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionCountGetAsyncWithHttpInfo
     *
     * Get application offline session count Returns a number of offline user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionCountGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'][0])
    {
        $returnType = 'array<string,int>';
        $request = $this->adminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidOfflineSessionCountGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionCountGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionCountGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidOfflineSessionCountGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidOfflineSessionCountGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/offline-session-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionsGet
     *
     * Get offline sessions for client Returns a list of offline user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionsGet($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidOfflineSessionsGetWithHttpInfo($realm, $client_uuid, $first, $max, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionsGetWithHttpInfo
     *
     * Get offline sessions for client Returns a list of offline user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionsGetWithHttpInfo($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidOfflineSessionsGetRequest($realm, $client_uuid, $first, $max, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionsGetAsync
     *
     * Get offline sessions for client Returns a list of offline user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionsGetAsync($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidOfflineSessionsGetAsyncWithHttpInfo($realm, $client_uuid, $first, $max, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOfflineSessionsGetAsyncWithHttpInfo
     *
     * Get offline sessions for client Returns a list of offline user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionsGetAsyncWithHttpInfo($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidOfflineSessionsGetRequest($realm, $client_uuid, $first, $max, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidOfflineSessionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidOfflineSessionsGetRequest($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOfflineSessionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidOfflineSessionsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidOfflineSessionsGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/offline-sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteAsync($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutAsync($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPutRequest($realm, $client_uuid, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmClientsClientUuidOptionalClientScopesClientScopeIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesGet
     *
     * Get optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesGetWithHttpInfo
     *
     * Get optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesGetAsync
     *
     * Get optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidOptionalClientScopesGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidOptionalClientScopesGetAsyncWithHttpInfo
     *
     * Get optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidOptionalClientScopesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidOptionalClientScopesGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidOptionalClientScopesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidOptionalClientScopesGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidOptionalClientScopesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/optional-client-scopes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPushRevocationPost
     *
     * Push the client&#39;s revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult
     */
    public function adminRealmsRealmClientsClientUuidPushRevocationPost($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidPushRevocationPostWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPushRevocationPostWithHttpInfo
     *
     * Push the client&#39;s revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidPushRevocationPostWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidPushRevocationPostRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPushRevocationPostAsync
     *
     * Push the client&#39;s revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidPushRevocationPostAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidPushRevocationPostAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPushRevocationPostAsyncWithHttpInfo
     *
     * Push the client&#39;s revocation policy to its admin URL If the client has an admin URL, push revocation policy to it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidPushRevocationPostAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
        $request = $this->adminRealmsRealmClientsClientUuidPushRevocationPostRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidPushRevocationPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidPushRevocationPostRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPushRevocationPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidPushRevocationPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidPushRevocationPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/push-revocation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPut
     *
     * Update the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidPut($realm, $client_uuid, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidPutWithHttpInfo($realm, $client_uuid, $client_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPutWithHttpInfo
     *
     * Update the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidPutWithHttpInfo($realm, $client_uuid, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidPutRequest($realm, $client_uuid, $client_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPutAsync
     *
     * Update the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidPutAsync($realm, $client_uuid, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidPutAsyncWithHttpInfo($realm, $client_uuid, $client_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidPutAsyncWithHttpInfo
     *
     * Update the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidPutAsyncWithHttpInfo($realm, $client_uuid, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidPutRequest($realm, $client_uuid, $client_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidPutRequest($realm, $client_uuid, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($client_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($client_representation));
            } else {
                $httpBody = $client_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost
     *
     * Generate a new registration access token for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation
     */
    public function adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostWithHttpInfo
     *
     * Generate a new registration access token for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostAsync
     *
     * Generate a new registration access token for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostAsyncWithHttpInfo
     *
     * Generate a new registration access token for the client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidRegistrationAccessTokenPostRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidRegistrationAccessTokenPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/registration-access-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidServiceAccountUserGet
     *
     * Get a user dedicated to the service account
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation
     */
    public function adminRealmsRealmClientsClientUuidServiceAccountUserGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidServiceAccountUserGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidServiceAccountUserGetWithHttpInfo
     *
     * Get a user dedicated to the service account
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidServiceAccountUserGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidServiceAccountUserGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidServiceAccountUserGetAsync
     *
     * Get a user dedicated to the service account
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidServiceAccountUserGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidServiceAccountUserGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidServiceAccountUserGetAsyncWithHttpInfo
     *
     * Get a user dedicated to the service account
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidServiceAccountUserGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidServiceAccountUserGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidServiceAccountUserGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidServiceAccountUserGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidServiceAccountUserGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidServiceAccountUserGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidServiceAccountUserGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/service-account-user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidSessionCountGet
     *
     * Get application session count Returns a number of user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,int>
     */
    public function adminRealmsRealmClientsClientUuidSessionCountGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidSessionCountGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidSessionCountGetWithHttpInfo
     *
     * Get application session count Returns a number of user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,int>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidSessionCountGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidSessionCountGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,int>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,int>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,int>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,int>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,int>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidSessionCountGetAsync
     *
     * Get application session count Returns a number of user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidSessionCountGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidSessionCountGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidSessionCountGetAsyncWithHttpInfo
     *
     * Get application session count Returns a number of user sessions associated with this client { \&quot;count\&quot;: number }
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidSessionCountGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'][0])
    {
        $returnType = 'array<string,int>';
        $request = $this->adminRealmsRealmClientsClientUuidSessionCountGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidSessionCountGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidSessionCountGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidSessionCountGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidSessionCountGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidSessionCountGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/session-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidTestNodesAvailableGet
     *
     * Test if registered cluster nodes are available Tests availability by sending &#39;ping&#39; request to all cluster nodes.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult
     */
    public function adminRealmsRealmClientsClientUuidTestNodesAvailableGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidTestNodesAvailableGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidTestNodesAvailableGetWithHttpInfo
     *
     * Test if registered cluster nodes are available Tests availability by sending &#39;ping&#39; request to all cluster nodes.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidTestNodesAvailableGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidTestNodesAvailableGetAsync
     *
     * Test if registered cluster nodes are available Tests availability by sending &#39;ping&#39; request to all cluster nodes.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidTestNodesAvailableGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidTestNodesAvailableGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidTestNodesAvailableGetAsyncWithHttpInfo
     *
     * Test if registered cluster nodes are available Tests availability by sending &#39;ping&#39; request to all cluster nodes.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidTestNodesAvailableGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
        $request = $this->adminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidTestNodesAvailableGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidTestNodesAvailableGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidTestNodesAvailableGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidTestNodesAvailableGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidTestNodesAvailableGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/test-nodes-available';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidUserSessionsGet
     *
     * Get user sessions for client Returns a list of user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidUserSessionsGet($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidUserSessionsGetWithHttpInfo($realm, $client_uuid, $first, $max, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidUserSessionsGetWithHttpInfo
     *
     * Get user sessions for client Returns a list of user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidUserSessionsGetWithHttpInfo($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidUserSessionsGetRequest($realm, $client_uuid, $first, $max, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidUserSessionsGetAsync
     *
     * Get user sessions for client Returns a list of user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidUserSessionsGetAsync($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidUserSessionsGetAsyncWithHttpInfo($realm, $client_uuid, $first, $max, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidUserSessionsGetAsyncWithHttpInfo
     *
     * Get user sessions for client Returns a list of user sessions associated with this client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidUserSessionsGetAsyncWithHttpInfo($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidUserSessionsGetRequest($realm, $client_uuid, $first, $max, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidUserSessionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first Paging offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidUserSessionsGetRequest($realm, $client_uuid, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidUserSessionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidUserSessionsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidUserSessionsGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/user-sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsGet
     *
     * Get clients belonging to the realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_id filter by clientId (optional)
     * @param  int $first the first result (optional)
     * @param  int $max the max results to return (optional)
     * @param  string $q q (optional)
     * @param  bool $search whether this is a search query or a getClientById query (optional, default to false)
     * @param  bool $viewable_only filter clients that cannot be viewed in full by admin (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]
     */
    public function adminRealmsRealmClientsGet($realm, $client_id = null, $first = null, $max = null, $q = null, $search = false, $viewable_only = false, string $contentType = self::contentTypes['adminRealmsRealmClientsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsGetWithHttpInfo($realm, $client_id, $first, $max, $q, $search, $viewable_only, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsGetWithHttpInfo
     *
     * Get clients belonging to the realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_id filter by clientId (optional)
     * @param  int $first the first result (optional)
     * @param  int $max the max results to return (optional)
     * @param  string $q (optional)
     * @param  bool $search whether this is a search query or a getClientById query (optional, default to false)
     * @param  bool $viewable_only filter clients that cannot be viewed in full by admin (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsGetWithHttpInfo($realm, $client_id = null, $first = null, $max = null, $q = null, $search = false, $viewable_only = false, string $contentType = self::contentTypes['adminRealmsRealmClientsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsGetRequest($realm, $client_id, $first, $max, $q, $search, $viewable_only, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsGetAsync
     *
     * Get clients belonging to the realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_id filter by clientId (optional)
     * @param  int $first the first result (optional)
     * @param  int $max the max results to return (optional)
     * @param  string $q (optional)
     * @param  bool $search whether this is a search query or a getClientById query (optional, default to false)
     * @param  bool $viewable_only filter clients that cannot be viewed in full by admin (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsGetAsync($realm, $client_id = null, $first = null, $max = null, $q = null, $search = false, $viewable_only = false, string $contentType = self::contentTypes['adminRealmsRealmClientsGet'][0])
    {
        return $this->adminRealmsRealmClientsGetAsyncWithHttpInfo($realm, $client_id, $first, $max, $q, $search, $viewable_only, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsGetAsyncWithHttpInfo
     *
     * Get clients belonging to the realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_id filter by clientId (optional)
     * @param  int $first the first result (optional)
     * @param  int $max the max results to return (optional)
     * @param  string $q (optional)
     * @param  bool $search whether this is a search query or a getClientById query (optional, default to false)
     * @param  bool $viewable_only filter clients that cannot be viewed in full by admin (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsGetAsyncWithHttpInfo($realm, $client_id = null, $first = null, $max = null, $q = null, $search = false, $viewable_only = false, string $contentType = self::contentTypes['adminRealmsRealmClientsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation[]';
        $request = $this->adminRealmsRealmClientsGetRequest($realm, $client_id, $first, $max, $q, $search, $viewable_only, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_id filter by clientId (optional)
     * @param  int $first the first result (optional)
     * @param  int $max the max results to return (optional)
     * @param  string $q (optional)
     * @param  bool $search whether this is a search query or a getClientById query (optional, default to false)
     * @param  bool $viewable_only filter clients that cannot be viewed in full by admin (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsGetRequest($realm, $client_id = null, $first = null, $max = null, $q = null, $search = false, $viewable_only = false, string $contentType = self::contentTypes['adminRealmsRealmClientsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsGet'
            );
        }








        $resourcePath = '/admin/realms/{realm}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'clientId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $viewable_only,
            'viewableOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsPost
     *
     * Create a new client Client’s client_id must be unique!
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsPost($realm, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsPost'][0])
    {
        $this->adminRealmsRealmClientsPostWithHttpInfo($realm, $client_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsPostWithHttpInfo
     *
     * Create a new client Client’s client_id must be unique!
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsPostWithHttpInfo($realm, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsPost'][0])
    {
        $request = $this->adminRealmsRealmClientsPostRequest($realm, $client_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsPostAsync
     *
     * Create a new client Client’s client_id must be unique!
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsPostAsync($realm, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsPost'][0])
    {
        return $this->adminRealmsRealmClientsPostAsyncWithHttpInfo($realm, $client_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsPostAsyncWithHttpInfo
     *
     * Create a new client Client’s client_id must be unique!
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsPostAsyncWithHttpInfo($realm, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsPostRequest($realm, $client_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation $client_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsPostRequest($realm, $client_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($client_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($client_representation));
            } else {
                $httpBody = $client_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
