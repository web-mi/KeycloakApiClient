<?php
/**
 * GroupsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * GroupsApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class GroupsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsRealmGroupsCountGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdChildrenGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdChildrenPost' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdManagementPermissionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdManagementPermissionsPut' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdMembersGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsGroupIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmGroupsPost' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsRealmGroupsCountGet
     *
     * Returns the groups counts.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $search search (optional)
     * @param  bool $top top (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,int>
     */
    public function adminRealmsRealmGroupsCountGet($realm, $search = null, $top = false, string $contentType = self::contentTypes['adminRealmsRealmGroupsCountGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsCountGetWithHttpInfo($realm, $search, $top, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsCountGetWithHttpInfo
     *
     * Returns the groups counts.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $search (optional)
     * @param  bool $top (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,int>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsCountGetWithHttpInfo($realm, $search = null, $top = false, string $contentType = self::contentTypes['adminRealmsRealmGroupsCountGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsCountGetRequest($realm, $search, $top, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,int>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,int>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,int>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,int>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,int>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsCountGetAsync
     *
     * Returns the groups counts.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $search (optional)
     * @param  bool $top (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsCountGetAsync($realm, $search = null, $top = false, string $contentType = self::contentTypes['adminRealmsRealmGroupsCountGet'][0])
    {
        return $this->adminRealmsRealmGroupsCountGetAsyncWithHttpInfo($realm, $search, $top, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsCountGetAsyncWithHttpInfo
     *
     * Returns the groups counts.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $search (optional)
     * @param  bool $top (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsCountGetAsyncWithHttpInfo($realm, $search = null, $top = false, string $contentType = self::contentTypes['adminRealmsRealmGroupsCountGet'][0])
    {
        $returnType = 'array<string,int>';
        $request = $this->adminRealmsRealmGroupsCountGetRequest($realm, $search, $top, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsCountGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $search (optional)
     * @param  bool $top (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsCountGetRequest($realm, $search = null, $top = false, string $contentType = self::contentTypes['adminRealmsRealmGroupsCountGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsCountGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/groups/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $top,
            'top', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGet
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation brief_representation (optional, default to true)
     * @param  bool $exact exact (optional, default to false)
     * @param  int $first first (optional)
     * @param  int $max max (optional)
     * @param  bool $populate_hierarchy populate_hierarchy (optional, default to true)
     * @param  string $q q (optional)
     * @param  string $search search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]
     */
    public function adminRealmsRealmGroupsGet($realm, $brief_representation = true, $exact = false, $first = null, $max = null, $populate_hierarchy = true, $q = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGetWithHttpInfo($realm, $brief_representation, $exact, $first, $max, $populate_hierarchy, $q, $search, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGetWithHttpInfo
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  bool $exact (optional, default to false)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  bool $populate_hierarchy (optional, default to true)
     * @param  string $q (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGetWithHttpInfo($realm, $brief_representation = true, $exact = false, $first = null, $max = null, $populate_hierarchy = true, $q = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsGetRequest($realm, $brief_representation, $exact, $first, $max, $populate_hierarchy, $q, $search, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGetAsync
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  bool $exact (optional, default to false)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  bool $populate_hierarchy (optional, default to true)
     * @param  string $q (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGetAsync($realm, $brief_representation = true, $exact = false, $first = null, $max = null, $populate_hierarchy = true, $q = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGet'][0])
    {
        return $this->adminRealmsRealmGroupsGetAsyncWithHttpInfo($realm, $brief_representation, $exact, $first, $max, $populate_hierarchy, $q, $search, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGetAsyncWithHttpInfo
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  bool $exact (optional, default to false)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  bool $populate_hierarchy (optional, default to true)
     * @param  string $q (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGetAsyncWithHttpInfo($realm, $brief_representation = true, $exact = false, $first = null, $max = null, $populate_hierarchy = true, $q = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
        $request = $this->adminRealmsRealmGroupsGetRequest($realm, $brief_representation, $exact, $first, $max, $populate_hierarchy, $q, $search, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  bool $exact (optional, default to false)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  bool $populate_hierarchy (optional, default to true)
     * @param  string $q (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGetRequest($realm, $brief_representation = true, $exact = false, $first = null, $max = null, $populate_hierarchy = true, $q = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGet'
            );
        }









        $resourcePath = '/admin/realms/{realm}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact,
            'exact', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $populate_hierarchy,
            'populateHierarchy', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenGet
     *
     * Return a paginated list of subgroups that have a parent group corresponding to the group on the URL
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  bool $brief_representation Boolean which defines whether brief groups representations are returned or not (default: false) (optional, default to false)
     * @param  bool $exact Boolean which defines whether the params \&quot;search\&quot; must match exactly or not (optional)
     * @param  int $first The position of the first result to be returned (pagination offset). (optional)
     * @param  int $max The maximum number of results that are to be returned. Defaults to 10 (optional)
     * @param  string $search A String representing either an exact group name or a partial name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]
     */
    public function adminRealmsRealmGroupsGroupIdChildrenGet($realm, $group_id, $brief_representation = false, $exact = null, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGroupIdChildrenGetWithHttpInfo($realm, $group_id, $brief_representation, $exact, $first, $max, $search, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenGetWithHttpInfo
     *
     * Return a paginated list of subgroups that have a parent group corresponding to the group on the URL
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Boolean which defines whether brief groups representations are returned or not (default: false) (optional, default to false)
     * @param  bool $exact Boolean which defines whether the params \&quot;search\&quot; must match exactly or not (optional)
     * @param  int $first The position of the first result to be returned (pagination offset). (optional)
     * @param  int $max The maximum number of results that are to be returned. Defaults to 10 (optional)
     * @param  string $search A String representing either an exact group name or a partial name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdChildrenGetWithHttpInfo($realm, $group_id, $brief_representation = false, $exact = null, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdChildrenGetRequest($realm, $group_id, $brief_representation, $exact, $first, $max, $search, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenGetAsync
     *
     * Return a paginated list of subgroups that have a parent group corresponding to the group on the URL
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Boolean which defines whether brief groups representations are returned or not (default: false) (optional, default to false)
     * @param  bool $exact Boolean which defines whether the params \&quot;search\&quot; must match exactly or not (optional)
     * @param  int $first The position of the first result to be returned (pagination offset). (optional)
     * @param  int $max The maximum number of results that are to be returned. Defaults to 10 (optional)
     * @param  string $search A String representing either an exact group name or a partial name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdChildrenGetAsync($realm, $group_id, $brief_representation = false, $exact = null, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdChildrenGetAsyncWithHttpInfo($realm, $group_id, $brief_representation, $exact, $first, $max, $search, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenGetAsyncWithHttpInfo
     *
     * Return a paginated list of subgroups that have a parent group corresponding to the group on the URL
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Boolean which defines whether brief groups representations are returned or not (default: false) (optional, default to false)
     * @param  bool $exact Boolean which defines whether the params \&quot;search\&quot; must match exactly or not (optional)
     * @param  int $first The position of the first result to be returned (pagination offset). (optional)
     * @param  int $max The maximum number of results that are to be returned. Defaults to 10 (optional)
     * @param  string $search A String representing either an exact group name or a partial name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdChildrenGetAsyncWithHttpInfo($realm, $group_id, $brief_representation = false, $exact = null, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
        $request = $this->adminRealmsRealmGroupsGroupIdChildrenGetRequest($realm, $group_id, $brief_representation, $exact, $first, $max, $search, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdChildrenGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Boolean which defines whether brief groups representations are returned or not (default: false) (optional, default to false)
     * @param  bool $exact Boolean which defines whether the params \&quot;search\&quot; must match exactly or not (optional)
     * @param  int $first The position of the first result to be returned (pagination offset). (optional)
     * @param  int $max The maximum number of results that are to be returned. Defaults to 10 (optional)
     * @param  string $search A String representing either an exact group name or a partial name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdChildrenGetRequest($realm, $group_id, $brief_representation = false, $exact = null, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdChildrenGet'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdChildrenGet'
            );
        }







        $resourcePath = '/admin/realms/{realm}/groups/{group-id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact,
            'exact', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenPost
     *
     * Set or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmGroupsGroupIdChildrenPost($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'][0])
    {
        $this->adminRealmsRealmGroupsGroupIdChildrenPostWithHttpInfo($realm, $group_id, $group_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenPostWithHttpInfo
     *
     * Set or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdChildrenPostWithHttpInfo($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdChildrenPostRequest($realm, $group_id, $group_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenPostAsync
     *
     * Set or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdChildrenPostAsync($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdChildrenPostAsyncWithHttpInfo($realm, $group_id, $group_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdChildrenPostAsyncWithHttpInfo
     *
     * Set or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdChildrenPostAsyncWithHttpInfo($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmGroupsGroupIdChildrenPostRequest($realm, $group_id, $group_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdChildrenPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdChildrenPostRequest($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdChildrenPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdChildrenPost'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdChildrenPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/groups/{group-id}/children';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_representation));
            } else {
                $httpBody = $group_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmGroupsGroupIdDelete($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'][0])
    {
        $this->adminRealmsRealmGroupsGroupIdDeleteWithHttpInfo($realm, $group_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdDeleteWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdDeleteRequest($realm, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdDeleteAsync($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmGroupsGroupIdDeleteRequest($realm, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdDeleteRequest($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdDelete'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/groups/{group-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation
     */
    public function adminRealmsRealmGroupsGroupIdGet($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGroupIdGetWithHttpInfo($realm, $group_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdGetWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdGetRequest($realm, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdGetAsync($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdGet'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdGetAsyncWithHttpInfo($realm, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdGetAsyncWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation';
        $request = $this->adminRealmsRealmGroupsGroupIdGetRequest($realm, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdGetRequest($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdGet'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/groups/{group-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsGet
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsGet($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsGetWithHttpInfo($realm, $group_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsGetWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsGetWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest($realm, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsGetAsync
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsGetAsync($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdManagementPermissionsGetAsyncWithHttpInfo($realm, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsGetAsyncWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsGetAsyncWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest($realm, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdManagementPermissionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsGetRequest($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdManagementPermissionsGet'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdManagementPermissionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/groups/{group-id}/management/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsPut
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsPut($realm, $group_id, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsPutWithHttpInfo($realm, $group_id, $management_permission_reference, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsPutWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsPutWithHttpInfo($realm, $group_id, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest($realm, $group_id, $management_permission_reference, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsPutAsync
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsPutAsync($realm, $group_id, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdManagementPermissionsPutAsyncWithHttpInfo($realm, $group_id, $management_permission_reference, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdManagementPermissionsPutAsyncWithHttpInfo
     *
     * Return object stating whether client Authorization permissions have been initialized or not and a reference
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsPutAsyncWithHttpInfo($realm, $group_id, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest($realm, $group_id, $management_permission_reference, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdManagementPermissionsPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdManagementPermissionsPutRequest($realm, $group_id, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdManagementPermissionsPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdManagementPermissionsPut'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdManagementPermissionsPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/groups/{group-id}/management/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($management_permission_reference)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($management_permission_reference));
            } else {
                $httpBody = $management_permission_reference;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdMembersGet
     *
     * Get users Returns a stream of users, filtered according to query parameters
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  bool $brief_representation Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.) (optional)
     * @param  int $first Pagination offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]
     */
    public function adminRealmsRealmGroupsGroupIdMembersGet($realm, $group_id, $brief_representation = null, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupsGroupIdMembersGetWithHttpInfo($realm, $group_id, $brief_representation, $first, $max, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdMembersGetWithHttpInfo
     *
     * Get users Returns a stream of users, filtered according to query parameters
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.) (optional)
     * @param  int $first Pagination offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdMembersGetWithHttpInfo($realm, $group_id, $brief_representation = null, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdMembersGetRequest($realm, $group_id, $brief_representation, $first, $max, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdMembersGetAsync
     *
     * Get users Returns a stream of users, filtered according to query parameters
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.) (optional)
     * @param  int $first Pagination offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdMembersGetAsync($realm, $group_id, $brief_representation = null, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdMembersGetAsyncWithHttpInfo($realm, $group_id, $brief_representation, $first, $max, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdMembersGetAsyncWithHttpInfo
     *
     * Get users Returns a stream of users, filtered according to query parameters
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.) (optional)
     * @param  int $first Pagination offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdMembersGetAsyncWithHttpInfo($realm, $group_id, $brief_representation = null, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]';
        $request = $this->adminRealmsRealmGroupsGroupIdMembersGetRequest($realm, $group_id, $brief_representation, $first, $max, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdMembersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  bool $brief_representation Only return basic information (only guaranteed to return id, username, created, first and last name, email, enabled state, email verification state, federation link, and access. Note that it means that namely user attributes, required actions, and not before are not returned.) (optional)
     * @param  int $first Pagination offset (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdMembersGetRequest($realm, $group_id, $brief_representation = null, $first = null, $max = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdMembersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdMembersGet'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdMembersGet'
            );
        }





        $resourcePath = '/admin/realms/{realm}/groups/{group-id}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdPut
     *
     * Update group, ignores subgroups.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmGroupsGroupIdPut($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdPut'][0])
    {
        $this->adminRealmsRealmGroupsGroupIdPutWithHttpInfo($realm, $group_id, $group_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdPutWithHttpInfo
     *
     * Update group, ignores subgroups.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsGroupIdPutWithHttpInfo($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdPut'][0])
    {
        $request = $this->adminRealmsRealmGroupsGroupIdPutRequest($realm, $group_id, $group_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdPutAsync
     *
     * Update group, ignores subgroups.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdPutAsync($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdPut'][0])
    {
        return $this->adminRealmsRealmGroupsGroupIdPutAsyncWithHttpInfo($realm, $group_id, $group_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsGroupIdPutAsyncWithHttpInfo
     *
     * Update group, ignores subgroups.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsGroupIdPutAsyncWithHttpInfo($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmGroupsGroupIdPutRequest($realm, $group_id, $group_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsGroupIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsGroupIdPutRequest($realm, $group_id, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsGroupIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsGroupIdPut'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmGroupsGroupIdPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/groups/{group-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group-id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_representation));
            } else {
                $httpBody = $group_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupsPost
     *
     * create or add a top level realm groupSet or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmGroupsPost($realm, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsPost'][0])
    {
        $this->adminRealmsRealmGroupsPostWithHttpInfo($realm, $group_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmGroupsPostWithHttpInfo
     *
     * create or add a top level realm groupSet or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupsPostWithHttpInfo($realm, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsPost'][0])
    {
        $request = $this->adminRealmsRealmGroupsPostRequest($realm, $group_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupsPostAsync
     *
     * create or add a top level realm groupSet or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsPostAsync($realm, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsPost'][0])
    {
        return $this->adminRealmsRealmGroupsPostAsyncWithHttpInfo($realm, $group_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupsPostAsyncWithHttpInfo
     *
     * create or add a top level realm groupSet or create child.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupsPostAsyncWithHttpInfo($realm, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmGroupsPostRequest($realm, $group_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupsPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation $group_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupsPostRequest($realm, $group_representation = null, string $contentType = self::contentTypes['adminRealmsRealmGroupsPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupsPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group_representation));
            } else {
                $httpBody = $group_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
