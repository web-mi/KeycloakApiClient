<?php
/**
 * UsersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * UsersApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UsersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsRealmUsersCountGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersProfileGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersProfileMetadataGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersProfilePut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdConsentsClientDelete' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdConsentsGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut' => [
            'text/plain',
        ],
        'adminRealmsRealmUsersUserIdCredentialsGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdDisableCredentialTypesPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdExecuteActionsEmailPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdFederatedIdentityGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdFederatedIdentityProviderPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdGroupsCountGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdGroupsGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdGroupsGroupIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdGroupsGroupIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdImpersonationPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdLogoutPost' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdResetPasswordEmailPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdResetPasswordPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdSendVerifyEmailPut' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdSessionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersUserIdUnmanagedAttributesGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsRealmUsersCountGet
     *
     * Returns the number of users that match the given criteria.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $email email filter (optional)
     * @param  bool $email_verified email_verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  string $first_name first name filter (optional)
     * @param  string $last_name last name filter (optional)
     * @param  string $q q (optional)
     * @param  string $search arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username username filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function adminRealmsRealmUsersCountGet($realm, $email = null, $email_verified = null, $enabled = null, $first_name = null, $last_name = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersCountGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersCountGetWithHttpInfo($realm, $email, $email_verified, $enabled, $first_name, $last_name, $q, $search, $username, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersCountGetWithHttpInfo
     *
     * Returns the number of users that match the given criteria.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $email email filter (optional)
     * @param  bool $email_verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  string $first_name first name filter (optional)
     * @param  string $last_name last name filter (optional)
     * @param  string $q (optional)
     * @param  string $search arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username username filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersCountGetWithHttpInfo($realm, $email = null, $email_verified = null, $enabled = null, $first_name = null, $last_name = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersCountGet'][0])
    {
        $request = $this->adminRealmsRealmUsersCountGetRequest($realm, $email, $email_verified, $enabled, $first_name, $last_name, $q, $search, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersCountGetAsync
     *
     * Returns the number of users that match the given criteria.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $email email filter (optional)
     * @param  bool $email_verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  string $first_name first name filter (optional)
     * @param  string $last_name last name filter (optional)
     * @param  string $q (optional)
     * @param  string $search arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username username filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersCountGetAsync($realm, $email = null, $email_verified = null, $enabled = null, $first_name = null, $last_name = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersCountGet'][0])
    {
        return $this->adminRealmsRealmUsersCountGetAsyncWithHttpInfo($realm, $email, $email_verified, $enabled, $first_name, $last_name, $q, $search, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersCountGetAsyncWithHttpInfo
     *
     * Returns the number of users that match the given criteria.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $email email filter (optional)
     * @param  bool $email_verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  string $first_name first name filter (optional)
     * @param  string $last_name last name filter (optional)
     * @param  string $q (optional)
     * @param  string $search arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username username filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersCountGetAsyncWithHttpInfo($realm, $email = null, $email_verified = null, $enabled = null, $first_name = null, $last_name = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersCountGet'][0])
    {
        $returnType = 'int';
        $request = $this->adminRealmsRealmUsersCountGetRequest($realm, $email, $email_verified, $enabled, $first_name, $last_name, $q, $search, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersCountGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $email email filter (optional)
     * @param  bool $email_verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  string $first_name first name filter (optional)
     * @param  string $last_name last name filter (optional)
     * @param  string $q (optional)
     * @param  string $search arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username username filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersCountGetRequest($realm, $email = null, $email_verified = null, $enabled = null, $first_name = null, $last_name = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersCountGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersCountGet'
            );
        }










        $resourcePath = '/admin/realms/{realm}/users/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_verified,
            'emailVerified', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersGet
     *
     * Get users Returns a stream of users, filtered according to query parameters.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation Boolean which defines whether brief representations are returned (default: false) (optional)
     * @param  string $email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true (optional)
     * @param  bool $email_verified whether the email has been verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  bool $exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly (optional)
     * @param  int $first Pagination offset (optional)
     * @param  string $first_name A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true (optional)
     * @param  string $idp_alias The alias of an Identity Provider linked to the user (optional)
     * @param  string $idp_user_id The userId at an Identity Provider linked to the user (optional)
     * @param  string $last_name A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $q A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39; (optional)
     * @param  string $search A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]
     */
    public function adminRealmsRealmUsersGet($realm, $brief_representation = null, $email = null, $email_verified = null, $enabled = null, $exact = null, $first = null, $first_name = null, $idp_alias = null, $idp_user_id = null, $last_name = null, $max = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersGetWithHttpInfo($realm, $brief_representation, $email, $email_verified, $enabled, $exact, $first, $first_name, $idp_alias, $idp_user_id, $last_name, $max, $q, $search, $username, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersGetWithHttpInfo
     *
     * Get users Returns a stream of users, filtered according to query parameters.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation Boolean which defines whether brief representations are returned (default: false) (optional)
     * @param  string $email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true (optional)
     * @param  bool $email_verified whether the email has been verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  bool $exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly (optional)
     * @param  int $first Pagination offset (optional)
     * @param  string $first_name A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true (optional)
     * @param  string $idp_alias The alias of an Identity Provider linked to the user (optional)
     * @param  string $idp_user_id The userId at an Identity Provider linked to the user (optional)
     * @param  string $last_name A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $q A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39; (optional)
     * @param  string $search A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersGetWithHttpInfo($realm, $brief_representation = null, $email = null, $email_verified = null, $enabled = null, $exact = null, $first = null, $first_name = null, $idp_alias = null, $idp_user_id = null, $last_name = null, $max = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersGet'][0])
    {
        $request = $this->adminRealmsRealmUsersGetRequest($realm, $brief_representation, $email, $email_verified, $enabled, $exact, $first, $first_name, $idp_alias, $idp_user_id, $last_name, $max, $q, $search, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersGetAsync
     *
     * Get users Returns a stream of users, filtered according to query parameters.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation Boolean which defines whether brief representations are returned (default: false) (optional)
     * @param  string $email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true (optional)
     * @param  bool $email_verified whether the email has been verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  bool $exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly (optional)
     * @param  int $first Pagination offset (optional)
     * @param  string $first_name A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true (optional)
     * @param  string $idp_alias The alias of an Identity Provider linked to the user (optional)
     * @param  string $idp_user_id The userId at an Identity Provider linked to the user (optional)
     * @param  string $last_name A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $q A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39; (optional)
     * @param  string $search A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersGetAsync($realm, $brief_representation = null, $email = null, $email_verified = null, $enabled = null, $exact = null, $first = null, $first_name = null, $idp_alias = null, $idp_user_id = null, $last_name = null, $max = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersGet'][0])
    {
        return $this->adminRealmsRealmUsersGetAsyncWithHttpInfo($realm, $brief_representation, $email, $email_verified, $enabled, $exact, $first, $first_name, $idp_alias, $idp_user_id, $last_name, $max, $q, $search, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersGetAsyncWithHttpInfo
     *
     * Get users Returns a stream of users, filtered according to query parameters.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation Boolean which defines whether brief representations are returned (default: false) (optional)
     * @param  string $email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true (optional)
     * @param  bool $email_verified whether the email has been verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  bool $exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly (optional)
     * @param  int $first Pagination offset (optional)
     * @param  string $first_name A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true (optional)
     * @param  string $idp_alias The alias of an Identity Provider linked to the user (optional)
     * @param  string $idp_user_id The userId at an Identity Provider linked to the user (optional)
     * @param  string $last_name A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $q A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39; (optional)
     * @param  string $search A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersGetAsyncWithHttpInfo($realm, $brief_representation = null, $email = null, $email_verified = null, $enabled = null, $exact = null, $first = null, $first_name = null, $idp_alias = null, $idp_user_id = null, $last_name = null, $max = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation[]';
        $request = $this->adminRealmsRealmUsersGetRequest($realm, $brief_representation, $email, $email_verified, $enabled, $exact, $first, $first_name, $idp_alias, $idp_user_id, $last_name, $max, $q, $search, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $brief_representation Boolean which defines whether brief representations are returned (default: false) (optional)
     * @param  string $email A String contained in email, or the complete email, if param \&quot;exact\&quot; is true (optional)
     * @param  bool $email_verified whether the email has been verified (optional)
     * @param  bool $enabled Boolean representing if user is enabled or not (optional)
     * @param  bool $exact Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly (optional)
     * @param  int $first Pagination offset (optional)
     * @param  string $first_name A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true (optional)
     * @param  string $idp_alias The alias of an Identity Provider linked to the user (optional)
     * @param  string $idp_user_id The userId at an Identity Provider linked to the user (optional)
     * @param  string $last_name A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string $q A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39; (optional)
     * @param  string $search A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search. (optional)
     * @param  string $username A String contained in username, or the complete username, if param \&quot;exact\&quot; is true (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersGetRequest($realm, $brief_representation = null, $email = null, $email_verified = null, $enabled = null, $exact = null, $first = null, $first_name = null, $idp_alias = null, $idp_user_id = null, $last_name = null, $max = null, $q = null, $search = null, $username = null, string $contentType = self::contentTypes['adminRealmsRealmUsersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersGet'
            );
        }
















        $resourcePath = '/admin/realms/{realm}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_verified,
            'emailVerified', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enabled,
            'enabled', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact,
            'exact', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $idp_alias,
            'idpAlias', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $idp_user_id,
            'idpUserId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersPost
     *
     * Create a new user Username must be unique.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersPost($realm, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersPost'][0])
    {
        $this->adminRealmsRealmUsersPostWithHttpInfo($realm, $user_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersPostWithHttpInfo
     *
     * Create a new user Username must be unique.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersPostWithHttpInfo($realm, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersPost'][0])
    {
        $request = $this->adminRealmsRealmUsersPostRequest($realm, $user_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersPostAsync
     *
     * Create a new user Username must be unique.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersPostAsync($realm, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersPost'][0])
    {
        return $this->adminRealmsRealmUsersPostAsyncWithHttpInfo($realm, $user_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersPostAsyncWithHttpInfo
     *
     * Create a new user Username must be unique.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersPostAsyncWithHttpInfo($realm, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersPostRequest($realm, $user_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersPostRequest($realm, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_representation));
            } else {
                $httpBody = $user_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersProfileGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig
     */
    public function adminRealmsRealmUsersProfileGet($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersProfileGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersProfileGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersProfileGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileGet'][0])
    {
        $request = $this->adminRealmsRealmUsersProfileGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersProfileGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfileGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileGet'][0])
    {
        return $this->adminRealmsRealmUsersProfileGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersProfileGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfileGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig';
        $request = $this->adminRealmsRealmUsersProfileGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersProfileGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersProfileGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersProfileGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersProfileMetadataGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata
     */
    public function adminRealmsRealmUsersProfileMetadataGet($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersProfileMetadataGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersProfileMetadataGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersProfileMetadataGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'][0])
    {
        $request = $this->adminRealmsRealmUsersProfileMetadataGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersProfileMetadataGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfileMetadataGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'][0])
    {
        return $this->adminRealmsRealmUsersProfileMetadataGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersProfileMetadataGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfileMetadataGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserProfileMetadata';
        $request = $this->adminRealmsRealmUsersProfileMetadataGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersProfileMetadataGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersProfileMetadataGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersProfileMetadataGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersProfileMetadataGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/profile/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersProfilePut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig $up_config up_config (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfilePut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig
     */
    public function adminRealmsRealmUsersProfilePut($realm, $up_config = null, string $contentType = self::contentTypes['adminRealmsRealmUsersProfilePut'][0])
    {
        list($response) = $this->adminRealmsRealmUsersProfilePutWithHttpInfo($realm, $up_config, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersProfilePutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig $up_config (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfilePut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersProfilePutWithHttpInfo($realm, $up_config = null, string $contentType = self::contentTypes['adminRealmsRealmUsersProfilePut'][0])
    {
        $request = $this->adminRealmsRealmUsersProfilePutRequest($realm, $up_config, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersProfilePutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig $up_config (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfilePutAsync($realm, $up_config = null, string $contentType = self::contentTypes['adminRealmsRealmUsersProfilePut'][0])
    {
        return $this->adminRealmsRealmUsersProfilePutAsyncWithHttpInfo($realm, $up_config, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersProfilePutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig $up_config (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersProfilePutAsyncWithHttpInfo($realm, $up_config = null, string $contentType = self::contentTypes['adminRealmsRealmUsersProfilePut'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig';
        $request = $this->adminRealmsRealmUsersProfilePutRequest($realm, $up_config, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersProfilePut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UPConfig $up_config (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersProfilePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersProfilePutRequest($realm, $up_config = null, string $contentType = self::contentTypes['adminRealmsRealmUsersProfilePut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersProfilePut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($up_config)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($up_config));
            } else {
                $httpBody = $up_config;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet
     *
     * Return credential types, which are provided by the user storage where user is stored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetWithHttpInfo
     *
     * Return credential types, which are provided by the user storage where user is stored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetAsync
     *
     * Return credential types, which are provided by the user storage where user is stored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetAsyncWithHttpInfo
     *
     * Return credential types, which are provided by the user storage where user is stored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'][0])
    {
        $returnType = 'string[]';
        $request = $this->adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdConfiguredUserStorageCredentialTypesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/configured-user-storage-credential-types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsClientDelete
     *
     * Revoke consent and offline tokens for particular client from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $client Client id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdConsentsClientDelete($realm, $user_id, $client, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'][0])
    {
        $this->adminRealmsRealmUsersUserIdConsentsClientDeleteWithHttpInfo($realm, $user_id, $client, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsClientDeleteWithHttpInfo
     *
     * Revoke consent and offline tokens for particular client from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client Client id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdConsentsClientDeleteWithHttpInfo($realm, $user_id, $client, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdConsentsClientDeleteRequest($realm, $user_id, $client, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsClientDeleteAsync
     *
     * Revoke consent and offline tokens for particular client from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client Client id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConsentsClientDeleteAsync($realm, $user_id, $client, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'][0])
    {
        return $this->adminRealmsRealmUsersUserIdConsentsClientDeleteAsyncWithHttpInfo($realm, $user_id, $client, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsClientDeleteAsyncWithHttpInfo
     *
     * Revoke consent and offline tokens for particular client from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client Client id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConsentsClientDeleteAsyncWithHttpInfo($realm, $user_id, $client, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdConsentsClientDeleteRequest($realm, $user_id, $client, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdConsentsClientDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client Client id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdConsentsClientDeleteRequest($realm, $user_id, $client, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsClientDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdConsentsClientDelete'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdConsentsClientDelete'
            );
        }

        // verify the required parameter 'client' is set
        if ($client === null || (is_array($client) && count($client) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client when calling adminRealmsRealmUsersUserIdConsentsClientDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/consents/{client}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($client !== null) {
            $resourcePath = str_replace(
                '{' . 'client' . '}',
                ObjectSerializer::toPathValue($client),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsGet
     *
     * Get consents granted by the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>[]
     */
    public function adminRealmsRealmUsersUserIdConsentsGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdConsentsGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsGetWithHttpInfo
     *
     * Get consents granted by the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdConsentsGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdConsentsGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsGetAsync
     *
     * Get consents granted by the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConsentsGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdConsentsGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdConsentsGetAsyncWithHttpInfo
     *
     * Get consents granted by the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdConsentsGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'][0])
    {
        $returnType = 'array<string,mixed>[]';
        $request = $this->adminRealmsRealmUsersUserIdConsentsGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdConsentsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdConsentsGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdConsentsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdConsentsGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdConsentsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/consents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete
     *
     * Remove a credential for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $credential_id credential_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'][0])
    {
        $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteWithHttpInfo($realm, $user_id, $credential_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteWithHttpInfo
     *
     * Remove a credential for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteWithHttpInfo($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest($realm, $user_id, $credential_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteAsync
     *
     * Remove a credential for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteAsync($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'][0])
    {
        return $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteAsyncWithHttpInfo($realm, $user_id, $credential_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteAsyncWithHttpInfo
     *
     * Remove a credential for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteAsyncWithHttpInfo($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest($realm, $user_id, $credential_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdDeleteRequest($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'
            );
        }

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost
     *
     * Move a credential to a position behind another credential
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $new_previous_credential_id The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost($realm, $user_id, $credential_id, $new_previous_credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'][0])
    {
        $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostWithHttpInfo($realm, $user_id, $credential_id, $new_previous_credential_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostWithHttpInfo
     *
     * Move a credential to a position behind another credential
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $new_previous_credential_id The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostWithHttpInfo($realm, $user_id, $credential_id, $new_previous_credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest($realm, $user_id, $credential_id, $new_previous_credential_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostAsync
     *
     * Move a credential to a position behind another credential
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $new_previous_credential_id The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostAsync($realm, $user_id, $credential_id, $new_previous_credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'][0])
    {
        return $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostAsyncWithHttpInfo($realm, $user_id, $credential_id, $new_previous_credential_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostAsyncWithHttpInfo
     *
     * Move a credential to a position behind another credential
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $new_previous_credential_id The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostAsyncWithHttpInfo($realm, $user_id, $credential_id, $new_previous_credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest($realm, $user_id, $credential_id, $new_previous_credential_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $new_previous_credential_id The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPostRequest($realm, $user_id, $credential_id, $new_previous_credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'
            );
        }

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'
            );
        }

        // verify the required parameter 'new_previous_credential_id' is set
        if ($new_previous_credential_id === null || (is_array($new_previous_credential_id) && count($new_previous_credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $new_previous_credential_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }
        // path params
        if ($new_previous_credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'newPreviousCredentialId' . '}',
                ObjectSerializer::toPathValue($new_previous_credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost
     *
     * Move a credential to a first position in the credentials list of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'][0])
    {
        $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostWithHttpInfo($realm, $user_id, $credential_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostWithHttpInfo
     *
     * Move a credential to a first position in the credentials list of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostWithHttpInfo($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest($realm, $user_id, $credential_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostAsync
     *
     * Move a credential to a first position in the credentials list of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostAsync($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'][0])
    {
        return $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostAsyncWithHttpInfo($realm, $user_id, $credential_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostAsyncWithHttpInfo
     *
     * Move a credential to a first position in the credentials list of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostAsyncWithHttpInfo($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest($realm, $user_id, $credential_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id The credential to move (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPostRequest($realm, $user_id, $credential_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'
            );
        }

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdMoveToFirstPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveToFirst';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut
     *
     * Update a credential label for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $credential_id credential_id (required)
     * @param  string $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut($realm, $user_id, $credential_id, $body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutWithHttpInfo($realm, $user_id, $credential_id, $body, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutWithHttpInfo
     *
     * Update a credential label for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutWithHttpInfo($realm, $user_id, $credential_id, $body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest($realm, $user_id, $credential_id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutAsync
     *
     * Update a credential label for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutAsync($realm, $user_id, $credential_id, $body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutAsyncWithHttpInfo($realm, $user_id, $credential_id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutAsyncWithHttpInfo
     *
     * Update a credential label for a user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutAsyncWithHttpInfo($realm, $user_id, $credential_id, $body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest($realm, $user_id, $credential_id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $credential_id (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPutRequest($realm, $user_id, $credential_id, $body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'
            );
        }

        // verify the required parameter 'credential_id' is set
        if ($credential_id === null || (is_array($credential_id) && count($credential_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credential_id when calling adminRealmsRealmUsersUserIdCredentialsCredentialIdUserLabelPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/userLabel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($credential_id !== null) {
            $resourcePath = str_replace(
                '{' . 'credentialId' . '}',
                ObjectSerializer::toPathValue($credential_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]
     */
    public function adminRealmsRealmUsersUserIdCredentialsGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdCredentialsGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdCredentialsGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdCredentialsGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdCredentialsGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdCredentialsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdCredentialsGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation[]';
        $request = $this->adminRealmsRealmUsersUserIdCredentialsGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdCredentialsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdCredentialsGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdCredentialsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdCredentialsGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdCredentialsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/credentials';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDelete
     *
     * Delete the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdDelete($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDelete'][0])
    {
        $this->adminRealmsRealmUsersUserIdDeleteWithHttpInfo($realm, $user_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDeleteWithHttpInfo
     *
     * Delete the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdDeleteWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDelete'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdDeleteRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDeleteAsync
     *
     * Delete the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdDeleteAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDelete'][0])
    {
        return $this->adminRealmsRealmUsersUserIdDeleteAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDeleteAsyncWithHttpInfo
     *
     * Delete the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdDeleteAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdDeleteRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdDeleteRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdDelete'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDisableCredentialTypesPut
     *
     * Disable all credentials for a user of a specific type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string[] $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdDisableCredentialTypesPut($realm, $user_id, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdDisableCredentialTypesPutWithHttpInfo($realm, $user_id, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDisableCredentialTypesPutWithHttpInfo
     *
     * Disable all credentials for a user of a specific type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdDisableCredentialTypesPutWithHttpInfo($realm, $user_id, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest($realm, $user_id, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDisableCredentialTypesPutAsync
     *
     * Disable all credentials for a user of a specific type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdDisableCredentialTypesPutAsync($realm, $user_id, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdDisableCredentialTypesPutAsyncWithHttpInfo($realm, $user_id, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdDisableCredentialTypesPutAsyncWithHttpInfo
     *
     * Disable all credentials for a user of a specific type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdDisableCredentialTypesPutAsyncWithHttpInfo($realm, $user_id, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest($realm, $user_id, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdDisableCredentialTypesPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdDisableCredentialTypesPutRequest($realm, $user_id, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdDisableCredentialTypesPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdDisableCredentialTypesPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdDisableCredentialTypesPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}/disable-credential-types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdExecuteActionsEmailPut
     *
     * Send an email to the user with a link they can click to execute particular actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string[] $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdExecuteActionsEmailPut($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdExecuteActionsEmailPutWithHttpInfo($realm, $user_id, $client_id, $lifespan, $redirect_uri, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdExecuteActionsEmailPutWithHttpInfo
     *
     * Send an email to the user with a link they can click to execute particular actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdExecuteActionsEmailPutWithHttpInfo($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest($realm, $user_id, $client_id, $lifespan, $redirect_uri, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdExecuteActionsEmailPutAsync
     *
     * Send an email to the user with a link they can click to execute particular actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdExecuteActionsEmailPutAsync($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdExecuteActionsEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id, $lifespan, $redirect_uri, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdExecuteActionsEmailPutAsyncWithHttpInfo
     *
     * Send an email to the user with a link they can click to execute particular actions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdExecuteActionsEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest($realm, $user_id, $client_id, $lifespan, $redirect_uri, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdExecuteActionsEmailPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string[] $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdExecuteActionsEmailPutRequest($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdExecuteActionsEmailPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdExecuteActionsEmailPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdExecuteActionsEmailPut'
            );
        }






        $resourcePath = '/admin/realms/{realm}/users/{user-id}/execute-actions-email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'client_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lifespan,
            'lifespan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $redirect_uri,
            'redirect_uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityGet
     *
     * Get social logins associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdFederatedIdentityGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityGetWithHttpInfo
     *
     * Get social logins associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityGetAsync
     *
     * Get social logins associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdFederatedIdentityGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityGetAsyncWithHttpInfo
     *
     * Get social logins associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\FederatedIdentityRepresentation[]';
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdFederatedIdentityGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdFederatedIdentityGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdFederatedIdentityGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/federated-identity';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete
     *
     * Remove a social login provider from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'][0])
    {
        $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteWithHttpInfo($realm, $user_id, $provider, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteWithHttpInfo
     *
     * Remove a social login provider from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteWithHttpInfo($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest($realm, $user_id, $provider, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteAsync
     *
     * Remove a social login provider from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteAsync($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'][0])
    {
        return $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteAsyncWithHttpInfo($realm, $user_id, $provider, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteAsyncWithHttpInfo
     *
     * Remove a social login provider from user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteAsyncWithHttpInfo($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest($realm, $user_id, $provider, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderDeleteRequest($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'
            );
        }

        // verify the required parameter 'provider' is set
        if ($provider === null || (is_array($provider) && count($provider) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($provider !== null) {
            $resourcePath = str_replace(
                '{' . 'provider' . '}',
                ObjectSerializer::toPathValue($provider),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderPost
     *
     * Add a social login provider to the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderPost($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'][0])
    {
        $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderPostWithHttpInfo($realm, $user_id, $provider, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderPostWithHttpInfo
     *
     * Add a social login provider to the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderPostWithHttpInfo($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest($realm, $user_id, $provider, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderPostAsync
     *
     * Add a social login provider to the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderPostAsync($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'][0])
    {
        return $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderPostAsyncWithHttpInfo($realm, $user_id, $provider, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdFederatedIdentityProviderPostAsyncWithHttpInfo
     *
     * Add a social login provider to the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderPostAsyncWithHttpInfo($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest($realm, $user_id, $provider, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $provider Social login provider id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdFederatedIdentityProviderPostRequest($realm, $user_id, $provider, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'
            );
        }

        // verify the required parameter 'provider' is set
        if ($provider === null || (is_array($provider) && count($provider) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $provider when calling adminRealmsRealmUsersUserIdFederatedIdentityProviderPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($provider !== null) {
            $resourcePath = str_replace(
                '{' . 'provider' . '}',
                ObjectSerializer::toPathValue($provider),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGet
     *
     * Get representation of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  bool $user_profile_metadata Indicates if the user profile metadata should be added to the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation
     */
    public function adminRealmsRealmUsersUserIdGet($realm, $user_id, $user_profile_metadata = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdGetWithHttpInfo($realm, $user_id, $user_profile_metadata, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGetWithHttpInfo
     *
     * Get representation of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $user_profile_metadata Indicates if the user profile metadata should be added to the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdGetWithHttpInfo($realm, $user_id, $user_profile_metadata = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdGetRequest($realm, $user_id, $user_profile_metadata, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGetAsync
     *
     * Get representation of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $user_profile_metadata Indicates if the user profile metadata should be added to the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGetAsync($realm, $user_id, $user_profile_metadata = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdGetAsyncWithHttpInfo($realm, $user_id, $user_profile_metadata, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGetAsyncWithHttpInfo
     *
     * Get representation of the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $user_profile_metadata Indicates if the user profile metadata should be added to the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGetAsyncWithHttpInfo($realm, $user_id, $user_profile_metadata = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation';
        $request = $this->adminRealmsRealmUsersUserIdGetRequest($realm, $user_id, $user_profile_metadata, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $user_profile_metadata Indicates if the user profile metadata should be added to the response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdGetRequest($realm, $user_id, $user_profile_metadata = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_profile_metadata,
            'userProfileMetadata', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsCountGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $search search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,int>
     */
    public function adminRealmsRealmUsersUserIdGroupsCountGet($realm, $user_id, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdGroupsCountGetWithHttpInfo($realm, $user_id, $search, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsCountGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,int>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdGroupsCountGetWithHttpInfo($realm, $user_id, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdGroupsCountGetRequest($realm, $user_id, $search, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,int>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,int>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,int>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,int>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,int>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsCountGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsCountGetAsync($realm, $user_id, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdGroupsCountGetAsyncWithHttpInfo($realm, $user_id, $search, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsCountGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsCountGetAsyncWithHttpInfo($realm, $user_id, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'][0])
    {
        $returnType = 'array<string,int>';
        $request = $this->adminRealmsRealmUsersUserIdGroupsCountGetRequest($realm, $user_id, $search, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdGroupsCountGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdGroupsCountGetRequest($realm, $user_id, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsCountGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdGroupsCountGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdGroupsCountGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}/groups/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  bool $brief_representation brief_representation (optional, default to true)
     * @param  int $first first (optional)
     * @param  int $max max (optional)
     * @param  string $search search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]
     */
    public function adminRealmsRealmUsersUserIdGroupsGet($realm, $user_id, $brief_representation = true, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdGroupsGetWithHttpInfo($realm, $user_id, $brief_representation, $first, $max, $search, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdGroupsGetWithHttpInfo($realm, $user_id, $brief_representation = true, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdGroupsGetRequest($realm, $user_id, $brief_representation, $first, $max, $search, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGetAsync($realm, $user_id, $brief_representation = true, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdGroupsGetAsyncWithHttpInfo($realm, $user_id, $brief_representation, $first, $max, $search, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGetAsyncWithHttpInfo($realm, $user_id, $brief_representation = true, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
        $request = $this->adminRealmsRealmUsersUserIdGroupsGetRequest($realm, $user_id, $brief_representation, $first, $max, $search, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdGroupsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  bool $brief_representation (optional, default to true)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $search (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdGroupsGetRequest($realm, $user_id, $brief_representation = true, $first = null, $max = null, $search = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdGroupsGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdGroupsGet'
            );
        }






        $resourcePath = '/admin/realms/{realm}/users/{user-id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdDelete($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'][0])
    {
        $this->adminRealmsRealmUsersUserIdGroupsGroupIdDeleteWithHttpInfo($realm, $user_id, $group_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdDeleteWithHttpInfo($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest($realm, $user_id, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdDeleteAsync($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'][0])
    {
        return $this->adminRealmsRealmUsersUserIdGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $user_id, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest($realm, $user_id, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdGroupsGroupIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdDeleteRequest($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdGroupsGroupIdDelete'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdGroupsGroupIdDelete'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmUsersUserIdGroupsGroupIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdPut($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdGroupsGroupIdPutWithHttpInfo($realm, $user_id, $group_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdPutWithHttpInfo($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdGroupsGroupIdPutRequest($realm, $user_id, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdPutAsync($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdGroupsGroupIdPutAsyncWithHttpInfo($realm, $user_id, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdGroupsGroupIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdPutAsyncWithHttpInfo($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdGroupsGroupIdPutRequest($realm, $user_id, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdGroupsGroupIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdGroupsGroupIdPutRequest($realm, $user_id, $group_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdGroupsGroupIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdGroupsGroupIdPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdGroupsGroupIdPut'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmUsersUserIdGroupsGroupIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdImpersonationPost
     *
     * Impersonate the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function adminRealmsRealmUsersUserIdImpersonationPost($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdImpersonationPostWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdImpersonationPostWithHttpInfo
     *
     * Impersonate the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdImpersonationPostWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdImpersonationPostRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,mixed>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,mixed>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdImpersonationPostAsync
     *
     * Impersonate the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdImpersonationPostAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'][0])
    {
        return $this->adminRealmsRealmUsersUserIdImpersonationPostAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdImpersonationPostAsyncWithHttpInfo
     *
     * Impersonate the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdImpersonationPostAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'][0])
    {
        $returnType = 'array<string,mixed>';
        $request = $this->adminRealmsRealmUsersUserIdImpersonationPostRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdImpersonationPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdImpersonationPostRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdImpersonationPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdImpersonationPost'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdImpersonationPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/impersonation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdLogoutPost
     *
     * Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdLogoutPost($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'][0])
    {
        $this->adminRealmsRealmUsersUserIdLogoutPostWithHttpInfo($realm, $user_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdLogoutPostWithHttpInfo
     *
     * Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdLogoutPostWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdLogoutPostRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdLogoutPostAsync
     *
     * Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdLogoutPostAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'][0])
    {
        return $this->adminRealmsRealmUsersUserIdLogoutPostAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdLogoutPostAsyncWithHttpInfo
     *
     * Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdLogoutPostAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdLogoutPostRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdLogoutPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdLogoutPostRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdLogoutPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdLogoutPost'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdLogoutPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet
     *
     * Get offline sessions associated with the user and client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $client_uuid client_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]
     */
    public function adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet($realm, $user_id, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetWithHttpInfo($realm, $user_id, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetWithHttpInfo
     *
     * Get offline sessions associated with the user and client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetWithHttpInfo($realm, $user_id, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest($realm, $user_id, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetAsync
     *
     * Get offline sessions associated with the user and client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetAsync($realm, $user_id, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetAsyncWithHttpInfo($realm, $user_id, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetAsyncWithHttpInfo
     *
     * Get offline sessions associated with the user and client
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetAsyncWithHttpInfo($realm, $user_id, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
        $request = $this->adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest($realm, $user_id, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_uuid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGetRequest($realm, $user_id, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmUsersUserIdOfflineSessionsClientUuidGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/offline-sessions/{clientUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'clientUuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdPut
     *
     * Update the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdPut($realm, $user_id, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdPutWithHttpInfo($realm, $user_id, $user_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdPutWithHttpInfo
     *
     * Update the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdPutWithHttpInfo($realm, $user_id, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdPutRequest($realm, $user_id, $user_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdPutAsync
     *
     * Update the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdPutAsync($realm, $user_id, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdPutAsyncWithHttpInfo($realm, $user_id, $user_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdPutAsyncWithHttpInfo
     *
     * Update the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdPutAsyncWithHttpInfo($realm, $user_id, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdPutRequest($realm, $user_id, $user_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\UserRepresentation $user_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdPutRequest($realm, $user_id, $user_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_representation));
            } else {
                $httpBody = $user_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordEmailPut
     *
     * Send an email to the user with a link they can click to reset their password.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $client_id client id (optional)
     * @param  string $redirect_uri redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function adminRealmsRealmUsersUserIdResetPasswordEmailPut($realm, $user_id, $client_id = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdResetPasswordEmailPutWithHttpInfo($realm, $user_id, $client_id, $redirect_uri, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordEmailPutWithHttpInfo
     *
     * Send an email to the user with a link they can click to reset their password.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id client id (optional)
     * @param  string $redirect_uri redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function adminRealmsRealmUsersUserIdResetPasswordEmailPutWithHttpInfo($realm, $user_id, $client_id = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdResetPasswordEmailPutRequest($realm, $user_id, $client_id, $redirect_uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordEmailPutAsync
     *
     * Send an email to the user with a link they can click to reset their password.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id client id (optional)
     * @param  string $redirect_uri redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmUsersUserIdResetPasswordEmailPutAsync($realm, $user_id, $client_id = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdResetPasswordEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id, $redirect_uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordEmailPutAsyncWithHttpInfo
     *
     * Send an email to the user with a link they can click to reset their password.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id client id (optional)
     * @param  string $redirect_uri redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmUsersUserIdResetPasswordEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdResetPasswordEmailPutRequest($realm, $user_id, $client_id, $redirect_uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdResetPasswordEmailPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id client id (optional)
     * @param  string $redirect_uri redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function adminRealmsRealmUsersUserIdResetPasswordEmailPutRequest($realm, $user_id, $client_id = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordEmailPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdResetPasswordEmailPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdResetPasswordEmailPut'
            );
        }




        $resourcePath = '/admin/realms/{realm}/users/{user-id}/reset-password-email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'client_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $redirect_uri,
            'redirect_uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordPut
     *
     * Set up a new password for the user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation $credential_representation credential_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdResetPasswordPut($realm, $user_id, $credential_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdResetPasswordPutWithHttpInfo($realm, $user_id, $credential_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordPutWithHttpInfo
     *
     * Set up a new password for the user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation $credential_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdResetPasswordPutWithHttpInfo($realm, $user_id, $credential_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdResetPasswordPutRequest($realm, $user_id, $credential_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordPutAsync
     *
     * Set up a new password for the user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation $credential_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdResetPasswordPutAsync($realm, $user_id, $credential_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdResetPasswordPutAsyncWithHttpInfo($realm, $user_id, $credential_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdResetPasswordPutAsyncWithHttpInfo
     *
     * Set up a new password for the user.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation $credential_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdResetPasswordPutAsyncWithHttpInfo($realm, $user_id, $credential_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdResetPasswordPutRequest($realm, $user_id, $credential_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdResetPasswordPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\CredentialRepresentation $credential_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdResetPasswordPutRequest($realm, $user_id, $credential_representation = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdResetPasswordPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdResetPasswordPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdResetPasswordPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users/{user-id}/reset-password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credential_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credential_representation));
            } else {
                $httpBody = $credential_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSendVerifyEmailPut
     *
     * Send an email-verification email to the user An email contains a link the user can click to verify their email address.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmUsersUserIdSendVerifyEmailPut($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'][0])
    {
        $this->adminRealmsRealmUsersUserIdSendVerifyEmailPutWithHttpInfo($realm, $user_id, $client_id, $lifespan, $redirect_uri, $contentType);
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSendVerifyEmailPutWithHttpInfo
     *
     * Send an email-verification email to the user An email contains a link the user can click to verify their email address.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdSendVerifyEmailPutWithHttpInfo($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdSendVerifyEmailPutRequest($realm, $user_id, $client_id, $lifespan, $redirect_uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSendVerifyEmailPutAsync
     *
     * Send an email-verification email to the user An email contains a link the user can click to verify their email address.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdSendVerifyEmailPutAsync($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'][0])
    {
        return $this->adminRealmsRealmUsersUserIdSendVerifyEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id, $lifespan, $redirect_uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSendVerifyEmailPutAsyncWithHttpInfo
     *
     * Send an email-verification email to the user An email contains a link the user can click to verify their email address.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdSendVerifyEmailPutAsyncWithHttpInfo($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmUsersUserIdSendVerifyEmailPutRequest($realm, $user_id, $client_id, $lifespan, $redirect_uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdSendVerifyEmailPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $client_id Client id (optional)
     * @param  int $lifespan Number of seconds after which the generated token expires (optional)
     * @param  string $redirect_uri Redirect uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdSendVerifyEmailPutRequest($realm, $user_id, $client_id = null, $lifespan = null, $redirect_uri = null, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSendVerifyEmailPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdSendVerifyEmailPut'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdSendVerifyEmailPut'
            );
        }





        $resourcePath = '/admin/realms/{realm}/users/{user-id}/send-verify-email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client_id,
            'client_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lifespan,
            'lifespan', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $redirect_uri,
            'redirect_uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSessionsGet
     *
     * Get sessions associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]
     */
    public function adminRealmsRealmUsersUserIdSessionsGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdSessionsGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSessionsGetWithHttpInfo
     *
     * Get sessions associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdSessionsGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdSessionsGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSessionsGetAsync
     *
     * Get sessions associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdSessionsGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdSessionsGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdSessionsGetAsyncWithHttpInfo
     *
     * Get sessions associated with the user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdSessionsGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\UserSessionRepresentation[]';
        $request = $this->adminRealmsRealmUsersUserIdSessionsGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdSessionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdSessionsGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdSessionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdSessionsGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdSessionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdUnmanagedAttributesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string[]>
     */
    public function adminRealmsRealmUsersUserIdUnmanagedAttributesGet($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersUserIdUnmanagedAttributesGetWithHttpInfo($realm, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersUserIdUnmanagedAttributesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string[]>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersUserIdUnmanagedAttributesGetWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'][0])
    {
        $request = $this->adminRealmsRealmUsersUserIdUnmanagedAttributesGetRequest($realm, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,string[]>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersUserIdUnmanagedAttributesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdUnmanagedAttributesGetAsync($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'][0])
    {
        return $this->adminRealmsRealmUsersUserIdUnmanagedAttributesGetAsyncWithHttpInfo($realm, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersUserIdUnmanagedAttributesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersUserIdUnmanagedAttributesGetAsyncWithHttpInfo($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'][0])
    {
        $returnType = 'array<string,string[]>';
        $request = $this->adminRealmsRealmUsersUserIdUnmanagedAttributesGetRequest($realm, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersUserIdUnmanagedAttributesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersUserIdUnmanagedAttributesGetRequest($realm, $user_id, string $contentType = self::contentTypes['adminRealmsRealmUsersUserIdUnmanagedAttributesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersUserIdUnmanagedAttributesGet'
            );
        }

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling adminRealmsRealmUsersUserIdUnmanagedAttributesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users/{user-id}/unmanagedAttributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user-id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
