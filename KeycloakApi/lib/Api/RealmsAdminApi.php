<?php
/**
 * RealmsAdminApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * RealmsAdminApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RealmsAdminApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsGet' => [
            'application/json',
        ],
        'adminRealmsPost' => [
            'application/json',
        ],
        'adminRealmsRealmAdminEventsDelete' => [
            'application/json',
        ],
        'adminRealmsRealmAdminEventsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientDescriptionConverterPost' => [
            'application/json',
            'application/xml',
            'text/plain',
        ],
        'adminRealmsRealmClientPoliciesPoliciesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientPoliciesPoliciesPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientPoliciesProfilesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientPoliciesProfilesPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientSessionStatsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientTypesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientTypesPut' => [
            'application/json',
        ],
        'adminRealmsRealmCredentialRegistratorsGet' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultDefaultClientScopesGet' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultGroupsGet' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultGroupsGroupIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultGroupsGroupIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmDefaultOptionalClientScopesGet' => [
            'application/json',
        ],
        'adminRealmsRealmDelete' => [
            'application/json',
        ],
        'adminRealmsRealmEventsConfigGet' => [
            'application/json',
        ],
        'adminRealmsRealmEventsConfigPut' => [
            'application/json',
        ],
        'adminRealmsRealmEventsDelete' => [
            'application/json',
        ],
        'adminRealmsRealmEventsGet' => [
            'application/json',
        ],
        'adminRealmsRealmGet' => [
            'application/json',
        ],
        'adminRealmsRealmGroupByPathPathGet' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationGet' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationLocaleDelete' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationLocaleGet' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationLocaleKeyDelete' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationLocaleKeyGet' => [
            'application/json',
        ],
        'adminRealmsRealmLocalizationLocaleKeyPut' => [
            'text/plain',
        ],
        'adminRealmsRealmLocalizationLocalePost' => [
            'application/json',
        ],
        'adminRealmsRealmLogoutAllPost' => [
            'application/json',
        ],
        'adminRealmsRealmPartialExportPost' => [
            'application/json',
        ],
        'adminRealmsRealmPartialImportPost' => [
            'application/json',
        ],
        'adminRealmsRealmPushRevocationPost' => [
            'application/json',
        ],
        'adminRealmsRealmPut' => [
            'application/json',
        ],
        'adminRealmsRealmSessionsSessionDelete' => [
            'application/json',
        ],
        'adminRealmsRealmTestSMTPConnectionPost' => [
            'application/json',
            'application/x-www-form-urlencoded',
        ],
        'adminRealmsRealmUsersManagementPermissionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmUsersManagementPermissionsPut' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsGet
     *
     * Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.
     *
     * @param  bool $brief_representation brief_representation (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]
     */
    public function adminRealmsGet($brief_representation = false, string $contentType = self::contentTypes['adminRealmsGet'][0])
    {
        list($response) = $this->adminRealmsGetWithHttpInfo($brief_representation, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsGetWithHttpInfo
     *
     * Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.
     *
     * @param  bool $brief_representation (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsGetWithHttpInfo($brief_representation = false, string $contentType = self::contentTypes['adminRealmsGet'][0])
    {
        $request = $this->adminRealmsGetRequest($brief_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsGetAsync
     *
     * Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.
     *
     * @param  bool $brief_representation (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsGetAsync($brief_representation = false, string $contentType = self::contentTypes['adminRealmsGet'][0])
    {
        return $this->adminRealmsGetAsyncWithHttpInfo($brief_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsGetAsyncWithHttpInfo
     *
     * Get accessible realms Returns a list of accessible realms. The list is filtered based on what realms the caller is allowed to view.
     *
     * @param  bool $brief_representation (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsGetAsyncWithHttpInfo($brief_representation = false, string $contentType = self::contentTypes['adminRealmsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation[]';
        $request = $this->adminRealmsGetRequest($brief_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsGet'
     *
     * @param  bool $brief_representation (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsGetRequest($brief_representation = false, string $contentType = self::contentTypes['adminRealmsGet'][0])
    {



        $resourcePath = '/admin/realms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $brief_representation,
            'briefRepresentation', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsPost
     *
     * Import a realm. Imports a realm from a full representation of that realm.
     *
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsPost($body = null, string $contentType = self::contentTypes['adminRealmsPost'][0])
    {
        $this->adminRealmsPostWithHttpInfo($body, $contentType);
    }

    /**
     * Operation adminRealmsPostWithHttpInfo
     *
     * Import a realm. Imports a realm from a full representation of that realm.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsPostWithHttpInfo($body = null, string $contentType = self::contentTypes['adminRealmsPost'][0])
    {
        $request = $this->adminRealmsPostRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsPostAsync
     *
     * Import a realm. Imports a realm from a full representation of that realm.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsPostAsync($body = null, string $contentType = self::contentTypes['adminRealmsPost'][0])
    {
        return $this->adminRealmsPostAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsPostAsyncWithHttpInfo
     *
     * Import a realm. Imports a realm from a full representation of that realm.
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsPostAsyncWithHttpInfo($body = null, string $contentType = self::contentTypes['adminRealmsPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsPostRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsPost'
     *
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsPostRequest($body = null, string $contentType = self::contentTypes['adminRealmsPost'][0])
    {



        $resourcePath = '/admin/realms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAdminEventsDelete
     *
     * Delete all admin events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmAdminEventsDelete($realm, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsDelete'][0])
    {
        $this->adminRealmsRealmAdminEventsDeleteWithHttpInfo($realm, $contentType);
    }

    /**
     * Operation adminRealmsRealmAdminEventsDeleteWithHttpInfo
     *
     * Delete all admin events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAdminEventsDeleteWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsDelete'][0])
    {
        $request = $this->adminRealmsRealmAdminEventsDeleteRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAdminEventsDeleteAsync
     *
     * Delete all admin events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAdminEventsDeleteAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsDelete'][0])
    {
        return $this->adminRealmsRealmAdminEventsDeleteAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAdminEventsDeleteAsyncWithHttpInfo
     *
     * Delete all admin events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAdminEventsDeleteAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmAdminEventsDeleteRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAdminEventsDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAdminEventsDeleteRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAdminEventsDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/admin-events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmAdminEventsGet
     *
     * Get admin events Returns all admin events, or filters events based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $auth_client auth_client (optional)
     * @param  string $auth_ip_address auth_ip_address (optional)
     * @param  string $auth_realm auth_realm (optional)
     * @param  string $auth_user user id (optional)
     * @param  string $date_from date_from (optional)
     * @param  string $date_to date_to (optional)
     * @param  int $first first (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $operation_types operation_types (optional)
     * @param  string $resource_path resource_path (optional)
     * @param  string[] $resource_types resource_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]
     */
    public function adminRealmsRealmAdminEventsGet($realm, $auth_client = null, $auth_ip_address = null, $auth_realm = null, $auth_user = null, $date_from = null, $date_to = null, $first = null, $max = null, $operation_types = null, $resource_path = null, $resource_types = null, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsGet'][0])
    {
        list($response) = $this->adminRealmsRealmAdminEventsGetWithHttpInfo($realm, $auth_client, $auth_ip_address, $auth_realm, $auth_user, $date_from, $date_to, $first, $max, $operation_types, $resource_path, $resource_types, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmAdminEventsGetWithHttpInfo
     *
     * Get admin events Returns all admin events, or filters events based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $auth_client (optional)
     * @param  string $auth_ip_address (optional)
     * @param  string $auth_realm (optional)
     * @param  string $auth_user user id (optional)
     * @param  string $date_from (optional)
     * @param  string $date_to (optional)
     * @param  int $first (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $operation_types (optional)
     * @param  string $resource_path (optional)
     * @param  string[] $resource_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmAdminEventsGetWithHttpInfo($realm, $auth_client = null, $auth_ip_address = null, $auth_realm = null, $auth_user = null, $date_from = null, $date_to = null, $first = null, $max = null, $operation_types = null, $resource_path = null, $resource_types = null, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsGet'][0])
    {
        $request = $this->adminRealmsRealmAdminEventsGetRequest($realm, $auth_client, $auth_ip_address, $auth_realm, $auth_user, $date_from, $date_to, $first, $max, $operation_types, $resource_path, $resource_types, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmAdminEventsGetAsync
     *
     * Get admin events Returns all admin events, or filters events based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $auth_client (optional)
     * @param  string $auth_ip_address (optional)
     * @param  string $auth_realm (optional)
     * @param  string $auth_user user id (optional)
     * @param  string $date_from (optional)
     * @param  string $date_to (optional)
     * @param  int $first (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $operation_types (optional)
     * @param  string $resource_path (optional)
     * @param  string[] $resource_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAdminEventsGetAsync($realm, $auth_client = null, $auth_ip_address = null, $auth_realm = null, $auth_user = null, $date_from = null, $date_to = null, $first = null, $max = null, $operation_types = null, $resource_path = null, $resource_types = null, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsGet'][0])
    {
        return $this->adminRealmsRealmAdminEventsGetAsyncWithHttpInfo($realm, $auth_client, $auth_ip_address, $auth_realm, $auth_user, $date_from, $date_to, $first, $max, $operation_types, $resource_path, $resource_types, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmAdminEventsGetAsyncWithHttpInfo
     *
     * Get admin events Returns all admin events, or filters events based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $auth_client (optional)
     * @param  string $auth_ip_address (optional)
     * @param  string $auth_realm (optional)
     * @param  string $auth_user user id (optional)
     * @param  string $date_from (optional)
     * @param  string $date_to (optional)
     * @param  int $first (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $operation_types (optional)
     * @param  string $resource_path (optional)
     * @param  string[] $resource_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmAdminEventsGetAsyncWithHttpInfo($realm, $auth_client = null, $auth_ip_address = null, $auth_realm = null, $auth_user = null, $date_from = null, $date_to = null, $first = null, $max = null, $operation_types = null, $resource_path = null, $resource_types = null, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AdminEventRepresentation[]';
        $request = $this->adminRealmsRealmAdminEventsGetRequest($realm, $auth_client, $auth_ip_address, $auth_realm, $auth_user, $date_from, $date_to, $first, $max, $operation_types, $resource_path, $resource_types, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmAdminEventsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $auth_client (optional)
     * @param  string $auth_ip_address (optional)
     * @param  string $auth_realm (optional)
     * @param  string $auth_user user id (optional)
     * @param  string $date_from (optional)
     * @param  string $date_to (optional)
     * @param  int $first (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $operation_types (optional)
     * @param  string $resource_path (optional)
     * @param  string[] $resource_types (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmAdminEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmAdminEventsGetRequest($realm, $auth_client = null, $auth_ip_address = null, $auth_realm = null, $auth_user = null, $date_from = null, $date_to = null, $first = null, $max = null, $operation_types = null, $resource_path = null, $resource_types = null, string $contentType = self::contentTypes['adminRealmsRealmAdminEventsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmAdminEventsGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/admin-events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_client,
            'authClient', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_ip_address,
            'authIpAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_realm,
            'authRealm', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $auth_user,
            'authUser', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $operation_types,
            'operationTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource_path,
            'resourcePath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource_types,
            'resourceTypes', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientDescriptionConverterPost
     *
     * Base path for importing clients under this realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation
     */
    public function adminRealmsRealmClientDescriptionConverterPost($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'][0])
    {
        list($response) = $this->adminRealmsRealmClientDescriptionConverterPostWithHttpInfo($realm, $body, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientDescriptionConverterPostWithHttpInfo
     *
     * Base path for importing clients under this realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientDescriptionConverterPostWithHttpInfo($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'][0])
    {
        $request = $this->adminRealmsRealmClientDescriptionConverterPostRequest($realm, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientDescriptionConverterPostAsync
     *
     * Base path for importing clients under this realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientDescriptionConverterPostAsync($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'][0])
    {
        return $this->adminRealmsRealmClientDescriptionConverterPostAsyncWithHttpInfo($realm, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientDescriptionConverterPostAsyncWithHttpInfo
     *
     * Base path for importing clients under this realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientDescriptionConverterPostAsyncWithHttpInfo($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientRepresentation';
        $request = $this->adminRealmsRealmClientDescriptionConverterPostRequest($realm, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientDescriptionConverterPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientDescriptionConverterPostRequest($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientDescriptionConverterPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientDescriptionConverterPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-description-converter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_policies include_global_policies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation
     */
    public function adminRealmsRealmClientPoliciesPoliciesGet($realm, $include_global_policies = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientPoliciesPoliciesGetWithHttpInfo($realm, $include_global_policies, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_policies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientPoliciesPoliciesGetWithHttpInfo($realm, $include_global_policies = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'][0])
    {
        $request = $this->adminRealmsRealmClientPoliciesPoliciesGetRequest($realm, $include_global_policies, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_policies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesPoliciesGetAsync($realm, $include_global_policies = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'][0])
    {
        return $this->adminRealmsRealmClientPoliciesPoliciesGetAsyncWithHttpInfo($realm, $include_global_policies, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_policies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesPoliciesGetAsyncWithHttpInfo($realm, $include_global_policies = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation';
        $request = $this->adminRealmsRealmClientPoliciesPoliciesGetRequest($realm, $include_global_policies, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientPoliciesPoliciesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_policies (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientPoliciesPoliciesGetRequest($realm, $include_global_policies = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientPoliciesPoliciesGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-policies/policies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_global_policies,
            'include-global-policies', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation $client_policies_representation client_policies_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientPoliciesPoliciesPut($realm, $client_policies_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'][0])
    {
        $this->adminRealmsRealmClientPoliciesPoliciesPutWithHttpInfo($realm, $client_policies_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation $client_policies_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientPoliciesPoliciesPutWithHttpInfo($realm, $client_policies_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'][0])
    {
        $request = $this->adminRealmsRealmClientPoliciesPoliciesPutRequest($realm, $client_policies_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation $client_policies_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesPoliciesPutAsync($realm, $client_policies_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'][0])
    {
        return $this->adminRealmsRealmClientPoliciesPoliciesPutAsyncWithHttpInfo($realm, $client_policies_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesPoliciesPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation $client_policies_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesPoliciesPutAsyncWithHttpInfo($realm, $client_policies_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientPoliciesPoliciesPutRequest($realm, $client_policies_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientPoliciesPoliciesPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientPoliciesRepresentation $client_policies_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientPoliciesPoliciesPutRequest($realm, $client_policies_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesPoliciesPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientPoliciesPoliciesPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-policies/policies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($client_policies_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($client_policies_representation));
            } else {
                $httpBody = $client_policies_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_profiles include_global_profiles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation
     */
    public function adminRealmsRealmClientPoliciesProfilesGet($realm, $include_global_profiles = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientPoliciesProfilesGetWithHttpInfo($realm, $include_global_profiles, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_profiles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientPoliciesProfilesGetWithHttpInfo($realm, $include_global_profiles = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'][0])
    {
        $request = $this->adminRealmsRealmClientPoliciesProfilesGetRequest($realm, $include_global_profiles, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_profiles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesProfilesGetAsync($realm, $include_global_profiles = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'][0])
    {
        return $this->adminRealmsRealmClientPoliciesProfilesGetAsyncWithHttpInfo($realm, $include_global_profiles, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_profiles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesProfilesGetAsyncWithHttpInfo($realm, $include_global_profiles = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation';
        $request = $this->adminRealmsRealmClientPoliciesProfilesGetRequest($realm, $include_global_profiles, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientPoliciesProfilesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $include_global_profiles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientPoliciesProfilesGetRequest($realm, $include_global_profiles = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientPoliciesProfilesGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-policies/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_global_profiles,
            'include-global-profiles', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation $client_profiles_representation client_profiles_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientPoliciesProfilesPut($realm, $client_profiles_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'][0])
    {
        $this->adminRealmsRealmClientPoliciesProfilesPutWithHttpInfo($realm, $client_profiles_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation $client_profiles_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientPoliciesProfilesPutWithHttpInfo($realm, $client_profiles_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'][0])
    {
        $request = $this->adminRealmsRealmClientPoliciesProfilesPutRequest($realm, $client_profiles_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation $client_profiles_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesProfilesPutAsync($realm, $client_profiles_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'][0])
    {
        return $this->adminRealmsRealmClientPoliciesProfilesPutAsyncWithHttpInfo($realm, $client_profiles_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientPoliciesProfilesPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation $client_profiles_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientPoliciesProfilesPutAsyncWithHttpInfo($realm, $client_profiles_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientPoliciesProfilesPutRequest($realm, $client_profiles_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientPoliciesProfilesPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientProfilesRepresentation $client_profiles_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientPoliciesProfilesPutRequest($realm, $client_profiles_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientPoliciesProfilesPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientPoliciesProfilesPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-policies/profiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($client_profiles_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($client_profiles_representation));
            } else {
                $httpBody = $client_profiles_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientSessionStatsGet
     *
     * Get client session stats Returns a JSON map.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientSessionStatsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string>[]
     */
    public function adminRealmsRealmClientSessionStatsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmClientSessionStatsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientSessionStatsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientSessionStatsGetWithHttpInfo
     *
     * Get client session stats Returns a JSON map.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientSessionStatsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string>[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientSessionStatsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmClientSessionStatsGet'][0])
    {
        $request = $this->adminRealmsRealmClientSessionStatsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,string>[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string>[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string>[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,string>[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string>[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientSessionStatsGetAsync
     *
     * Get client session stats Returns a JSON map.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientSessionStatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientSessionStatsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmClientSessionStatsGet'][0])
    {
        return $this->adminRealmsRealmClientSessionStatsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientSessionStatsGetAsyncWithHttpInfo
     *
     * Get client session stats Returns a JSON map.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientSessionStatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientSessionStatsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmClientSessionStatsGet'][0])
    {
        $returnType = 'array<string,string>[]';
        $request = $this->adminRealmsRealmClientSessionStatsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientSessionStatsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientSessionStatsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientSessionStatsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmClientSessionStatsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientSessionStatsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/client-session-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientTypesGet
     *
     * List all client types available in the current realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation
     */
    public function adminRealmsRealmClientTypesGet($realm, string $contentType = self::contentTypes['adminRealmsRealmClientTypesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientTypesGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientTypesGetWithHttpInfo
     *
     * List all client types available in the current realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientTypesGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmClientTypesGet'][0])
    {
        $request = $this->adminRealmsRealmClientTypesGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientTypesGetAsync
     *
     * List all client types available in the current realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientTypesGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmClientTypesGet'][0])
    {
        return $this->adminRealmsRealmClientTypesGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientTypesGetAsyncWithHttpInfo
     *
     * List all client types available in the current realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientTypesGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmClientTypesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation';
        $request = $this->adminRealmsRealmClientTypesGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientTypesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientTypesGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmClientTypesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientTypesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/client-types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientTypesPut
     *
     * Update a client type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation $client_types_representation client_types_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientTypesPut($realm, $client_types_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientTypesPut'][0])
    {
        $this->adminRealmsRealmClientTypesPutWithHttpInfo($realm, $client_types_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientTypesPutWithHttpInfo
     *
     * Update a client type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation $client_types_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientTypesPutWithHttpInfo($realm, $client_types_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientTypesPut'][0])
    {
        $request = $this->adminRealmsRealmClientTypesPutRequest($realm, $client_types_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientTypesPutAsync
     *
     * Update a client type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation $client_types_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientTypesPutAsync($realm, $client_types_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientTypesPut'][0])
    {
        return $this->adminRealmsRealmClientTypesPutAsyncWithHttpInfo($realm, $client_types_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientTypesPutAsyncWithHttpInfo
     *
     * Update a client type
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation $client_types_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientTypesPutAsyncWithHttpInfo($realm, $client_types_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientTypesPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientTypesPutRequest($realm, $client_types_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientTypesPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientTypesRepresentation $client_types_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientTypesPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientTypesPutRequest($realm, $client_types_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientTypesPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientTypesPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/client-types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($client_types_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($client_types_representation));
            } else {
                $httpBody = $client_types_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmCredentialRegistratorsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function adminRealmsRealmCredentialRegistratorsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'][0])
    {
        list($response) = $this->adminRealmsRealmCredentialRegistratorsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmCredentialRegistratorsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmCredentialRegistratorsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'][0])
    {
        $request = $this->adminRealmsRealmCredentialRegistratorsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmCredentialRegistratorsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmCredentialRegistratorsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'][0])
    {
        return $this->adminRealmsRealmCredentialRegistratorsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmCredentialRegistratorsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmCredentialRegistratorsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'][0])
    {
        $returnType = 'string[]';
        $request = $this->adminRealmsRealmCredentialRegistratorsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmCredentialRegistratorsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmCredentialRegistratorsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmCredentialRegistratorsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmCredentialRegistratorsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/credential-registrators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'][0])
    {
        $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'][0])
    {
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteAsync($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'][0])
    {
        return $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmDefaultDefaultClientScopesClientScopeIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'][0])
    {
        $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutWithHttpInfo($realm, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'][0])
    {
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest($realm, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutAsync($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'][0])
    {
        return $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest($realm, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPutRequest($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmDefaultDefaultClientScopesClientScopeIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-default-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesGet
     *
     * Get realm default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]
     */
    public function adminRealmsRealmDefaultDefaultClientScopesGet($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'][0])
    {
        list($response) = $this->adminRealmsRealmDefaultDefaultClientScopesGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesGetWithHttpInfo
     *
     * Get realm default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultDefaultClientScopesGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'][0])
    {
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesGetAsync
     *
     * Get realm default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'][0])
    {
        return $this->adminRealmsRealmDefaultDefaultClientScopesGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultDefaultClientScopesGetAsyncWithHttpInfo
     *
     * Get realm default client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultDefaultClientScopesGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
        $request = $this->adminRealmsRealmDefaultDefaultClientScopesGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultDefaultClientScopesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultDefaultClientScopesGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultDefaultClientScopesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultDefaultClientScopesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-default-client-scopes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGet
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]
     */
    public function adminRealmsRealmDefaultGroupsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGet'][0])
    {
        list($response) = $this->adminRealmsRealmDefaultGroupsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGetWithHttpInfo
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultGroupsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGet'][0])
    {
        $request = $this->adminRealmsRealmDefaultGroupsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGetAsync
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGet'][0])
    {
        return $this->adminRealmsRealmDefaultGroupsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGetAsyncWithHttpInfo
     *
     * Get group hierarchy.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation[]';
        $request = $this->adminRealmsRealmDefaultGroupsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultGroupsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultGroupsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultGroupsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultGroupsGroupIdDelete($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'][0])
    {
        $this->adminRealmsRealmDefaultGroupsGroupIdDeleteWithHttpInfo($realm, $group_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultGroupsGroupIdDeleteWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'][0])
    {
        $request = $this->adminRealmsRealmDefaultGroupsGroupIdDeleteRequest($realm, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGroupIdDeleteAsync($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'][0])
    {
        return $this->adminRealmsRealmDefaultGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGroupIdDeleteAsyncWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultGroupsGroupIdDeleteRequest($realm, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultGroupsGroupIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultGroupsGroupIdDeleteRequest($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultGroupsGroupIdDelete'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmDefaultGroupsGroupIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultGroupsGroupIdPut($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'][0])
    {
        $this->adminRealmsRealmDefaultGroupsGroupIdPutWithHttpInfo($realm, $group_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultGroupsGroupIdPutWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'][0])
    {
        $request = $this->adminRealmsRealmDefaultGroupsGroupIdPutRequest($realm, $group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGroupIdPutAsync($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'][0])
    {
        return $this->adminRealmsRealmDefaultGroupsGroupIdPutAsyncWithHttpInfo($realm, $group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultGroupsGroupIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultGroupsGroupIdPutAsyncWithHttpInfo($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultGroupsGroupIdPutRequest($realm, $group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultGroupsGroupIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $group_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultGroupsGroupIdPutRequest($realm, $group_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultGroupsGroupIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultGroupsGroupIdPut'
            );
        }

        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling adminRealmsRealmDefaultGroupsGroupIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-groups/{groupId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'][0])
    {
        $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'][0])
    {
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteAsync($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'][0])
    {
        return $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteAsyncWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDeleteRequest($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmDefaultOptionalClientScopesClientScopeIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'][0])
    {
        $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutWithHttpInfo($realm, $client_scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'][0])
    {
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest($realm, $client_scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutAsync($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'][0])
    {
        return $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutAsyncWithHttpInfo($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest($realm, $client_scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPutRequest($realm, $client_scope_id, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'
            );
        }

        // verify the required parameter 'client_scope_id' is set
        if ($client_scope_id === null || (is_array($client_scope_id) && count($client_scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_scope_id when calling adminRealmsRealmDefaultOptionalClientScopesClientScopeIdPut'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-optional-client-scopes/{clientScopeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientScopeId' . '}',
                ObjectSerializer::toPathValue($client_scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesGet
     *
     * Get realm optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]
     */
    public function adminRealmsRealmDefaultOptionalClientScopesGet($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'][0])
    {
        list($response) = $this->adminRealmsRealmDefaultOptionalClientScopesGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesGetWithHttpInfo
     *
     * Get realm optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDefaultOptionalClientScopesGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'][0])
    {
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesGetAsync
     *
     * Get realm optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'][0])
    {
        return $this->adminRealmsRealmDefaultOptionalClientScopesGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDefaultOptionalClientScopesGetAsyncWithHttpInfo
     *
     * Get realm optional client scopes.  Only name and ids are returned.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDefaultOptionalClientScopesGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ClientScopeRepresentation[]';
        $request = $this->adminRealmsRealmDefaultOptionalClientScopesGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDefaultOptionalClientScopesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDefaultOptionalClientScopesGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmDefaultOptionalClientScopesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDefaultOptionalClientScopesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/default-optional-client-scopes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmDelete
     *
     * Delete the realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmDelete($realm, string $contentType = self::contentTypes['adminRealmsRealmDelete'][0])
    {
        $this->adminRealmsRealmDeleteWithHttpInfo($realm, $contentType);
    }

    /**
     * Operation adminRealmsRealmDeleteWithHttpInfo
     *
     * Delete the realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmDeleteWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDelete'][0])
    {
        $request = $this->adminRealmsRealmDeleteRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmDeleteAsync
     *
     * Delete the realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDeleteAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmDelete'][0])
    {
        return $this->adminRealmsRealmDeleteAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmDeleteAsyncWithHttpInfo
     *
     * Delete the realm
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmDeleteAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmDeleteRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmDeleteRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmEventsConfigGet
     *
     * Get the events provider configuration Returns JSON object with events provider configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation
     */
    public function adminRealmsRealmEventsConfigGet($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigGet'][0])
    {
        list($response) = $this->adminRealmsRealmEventsConfigGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmEventsConfigGetWithHttpInfo
     *
     * Get the events provider configuration Returns JSON object with events provider configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmEventsConfigGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigGet'][0])
    {
        $request = $this->adminRealmsRealmEventsConfigGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmEventsConfigGetAsync
     *
     * Get the events provider configuration Returns JSON object with events provider configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsConfigGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigGet'][0])
    {
        return $this->adminRealmsRealmEventsConfigGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmEventsConfigGetAsyncWithHttpInfo
     *
     * Get the events provider configuration Returns JSON object with events provider configuration
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsConfigGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation';
        $request = $this->adminRealmsRealmEventsConfigGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmEventsConfigGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmEventsConfigGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmEventsConfigGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/events/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmEventsConfigPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation $realm_events_config_representation realm_events_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmEventsConfigPut($realm, $realm_events_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigPut'][0])
    {
        $this->adminRealmsRealmEventsConfigPutWithHttpInfo($realm, $realm_events_config_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmEventsConfigPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation $realm_events_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmEventsConfigPutWithHttpInfo($realm, $realm_events_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigPut'][0])
    {
        $request = $this->adminRealmsRealmEventsConfigPutRequest($realm, $realm_events_config_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmEventsConfigPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation $realm_events_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsConfigPutAsync($realm, $realm_events_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigPut'][0])
    {
        return $this->adminRealmsRealmEventsConfigPutAsyncWithHttpInfo($realm, $realm_events_config_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmEventsConfigPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation $realm_events_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsConfigPutAsyncWithHttpInfo($realm, $realm_events_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmEventsConfigPutRequest($realm, $realm_events_config_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmEventsConfigPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmEventsConfigRepresentation $realm_events_config_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsConfigPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmEventsConfigPutRequest($realm, $realm_events_config_representation = null, string $contentType = self::contentTypes['adminRealmsRealmEventsConfigPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmEventsConfigPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/events/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($realm_events_config_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($realm_events_config_representation));
            } else {
                $httpBody = $realm_events_config_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmEventsDelete
     *
     * Delete all events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmEventsDelete($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsDelete'][0])
    {
        $this->adminRealmsRealmEventsDeleteWithHttpInfo($realm, $contentType);
    }

    /**
     * Operation adminRealmsRealmEventsDeleteWithHttpInfo
     *
     * Delete all events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmEventsDeleteWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsDelete'][0])
    {
        $request = $this->adminRealmsRealmEventsDeleteRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmEventsDeleteAsync
     *
     * Delete all events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsDeleteAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsDelete'][0])
    {
        return $this->adminRealmsRealmEventsDeleteAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmEventsDeleteAsyncWithHttpInfo
     *
     * Delete all events
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsDeleteAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmEventsDeleteRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmEventsDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmEventsDeleteRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmEventsDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmEventsDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmEventsGet
     *
     * Get events Returns all events, or filters them based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client App or oauth client name (optional)
     * @param  string $date_from From date (optional)
     * @param  string $date_to To date (optional)
     * @param  int $first Paging offset (optional)
     * @param  string $ip_address IP Address (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $type The types of events to return (optional)
     * @param  string $user User id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]
     */
    public function adminRealmsRealmEventsGet($realm, $client = null, $date_from = null, $date_to = null, $first = null, $ip_address = null, $max = null, $type = null, $user = null, string $contentType = self::contentTypes['adminRealmsRealmEventsGet'][0])
    {
        list($response) = $this->adminRealmsRealmEventsGetWithHttpInfo($realm, $client, $date_from, $date_to, $first, $ip_address, $max, $type, $user, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmEventsGetWithHttpInfo
     *
     * Get events Returns all events, or filters them based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client App or oauth client name (optional)
     * @param  string $date_from From date (optional)
     * @param  string $date_to To date (optional)
     * @param  int $first Paging offset (optional)
     * @param  string $ip_address IP Address (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $type The types of events to return (optional)
     * @param  string $user User id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmEventsGetWithHttpInfo($realm, $client = null, $date_from = null, $date_to = null, $first = null, $ip_address = null, $max = null, $type = null, $user = null, string $contentType = self::contentTypes['adminRealmsRealmEventsGet'][0])
    {
        $request = $this->adminRealmsRealmEventsGetRequest($realm, $client, $date_from, $date_to, $first, $ip_address, $max, $type, $user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmEventsGetAsync
     *
     * Get events Returns all events, or filters them based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client App or oauth client name (optional)
     * @param  string $date_from From date (optional)
     * @param  string $date_to To date (optional)
     * @param  int $first Paging offset (optional)
     * @param  string $ip_address IP Address (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $type The types of events to return (optional)
     * @param  string $user User id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsGetAsync($realm, $client = null, $date_from = null, $date_to = null, $first = null, $ip_address = null, $max = null, $type = null, $user = null, string $contentType = self::contentTypes['adminRealmsRealmEventsGet'][0])
    {
        return $this->adminRealmsRealmEventsGetAsyncWithHttpInfo($realm, $client, $date_from, $date_to, $first, $ip_address, $max, $type, $user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmEventsGetAsyncWithHttpInfo
     *
     * Get events Returns all events, or filters them based on URL query parameters listed here
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client App or oauth client name (optional)
     * @param  string $date_from From date (optional)
     * @param  string $date_to To date (optional)
     * @param  int $first Paging offset (optional)
     * @param  string $ip_address IP Address (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $type The types of events to return (optional)
     * @param  string $user User id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmEventsGetAsyncWithHttpInfo($realm, $client = null, $date_from = null, $date_to = null, $first = null, $ip_address = null, $max = null, $type = null, $user = null, string $contentType = self::contentTypes['adminRealmsRealmEventsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\EventRepresentation[]';
        $request = $this->adminRealmsRealmEventsGetRequest($realm, $client, $date_from, $date_to, $first, $ip_address, $max, $type, $user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmEventsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client App or oauth client name (optional)
     * @param  string $date_from From date (optional)
     * @param  string $date_to To date (optional)
     * @param  int $first Paging offset (optional)
     * @param  string $ip_address IP Address (optional)
     * @param  int $max Maximum results size (defaults to 100) (optional)
     * @param  string[] $type The types of events to return (optional)
     * @param  string $user User id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmEventsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmEventsGetRequest($realm, $client = null, $date_from = null, $date_to = null, $first = null, $ip_address = null, $max = null, $type = null, $user = null, string $contentType = self::contentTypes['adminRealmsRealmEventsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmEventsGet'
            );
        }










        $resourcePath = '/admin/realms/{realm}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $client,
            'client', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_from,
            'dateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_to,
            'dateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ip_address,
            'ipAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user,
            'user', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGet
     *
     * Get the top-level representation of the realm It will not include nested information like User and Client representations.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation
     */
    public function adminRealmsRealmGet($realm, string $contentType = self::contentTypes['adminRealmsRealmGet'][0])
    {
        list($response) = $this->adminRealmsRealmGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGetWithHttpInfo
     *
     * Get the top-level representation of the realm It will not include nested information like User and Client representations.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmGet'][0])
    {
        $request = $this->adminRealmsRealmGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGetAsync
     *
     * Get the top-level representation of the realm It will not include nested information like User and Client representations.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmGet'][0])
    {
        return $this->adminRealmsRealmGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGetAsyncWithHttpInfo
     *
     * Get the top-level representation of the realm It will not include nested information like User and Client representations.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation';
        $request = $this->adminRealmsRealmGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmGroupByPathPathGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $path path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupByPathPathGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation
     */
    public function adminRealmsRealmGroupByPathPathGet($realm, $path, string $contentType = self::contentTypes['adminRealmsRealmGroupByPathPathGet'][0])
    {
        list($response) = $this->adminRealmsRealmGroupByPathPathGetWithHttpInfo($realm, $path, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmGroupByPathPathGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupByPathPathGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmGroupByPathPathGetWithHttpInfo($realm, $path, string $contentType = self::contentTypes['adminRealmsRealmGroupByPathPathGet'][0])
    {
        $request = $this->adminRealmsRealmGroupByPathPathGetRequest($realm, $path, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmGroupByPathPathGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupByPathPathGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupByPathPathGetAsync($realm, $path, string $contentType = self::contentTypes['adminRealmsRealmGroupByPathPathGet'][0])
    {
        return $this->adminRealmsRealmGroupByPathPathGetAsyncWithHttpInfo($realm, $path, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmGroupByPathPathGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupByPathPathGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmGroupByPathPathGetAsyncWithHttpInfo($realm, $path, string $contentType = self::contentTypes['adminRealmsRealmGroupByPathPathGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GroupRepresentation';
        $request = $this->adminRealmsRealmGroupByPathPathGetRequest($realm, $path, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmGroupByPathPathGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmGroupByPathPathGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmGroupByPathPathGetRequest($realm, $path, string $contentType = self::contentTypes['adminRealmsRealmGroupByPathPathGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmGroupByPathPathGet'
            );
        }

        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling adminRealmsRealmGroupByPathPathGet'
            );
        }
        if (!preg_match("/.*/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling RealmsAdminApi.adminRealmsRealmGroupByPathPathGet, must conform to the pattern /.*/.");
        }
        

        $resourcePath = '/admin/realms/{realm}/group-by-path/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string[]
     */
    public function adminRealmsRealmLocalizationGet($realm, string $contentType = self::contentTypes['adminRealmsRealmLocalizationGet'][0])
    {
        list($response) = $this->adminRealmsRealmLocalizationGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmLocalizationGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmLocalizationGet'][0])
    {
        $request = $this->adminRealmsRealmLocalizationGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmLocalizationGet'][0])
    {
        return $this->adminRealmsRealmLocalizationGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmLocalizationGet'][0])
    {
        $returnType = 'string[]';
        $request = $this->adminRealmsRealmLocalizationGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmLocalizationGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/localization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmLocalizationLocaleDelete($realm, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'][0])
    {
        $this->adminRealmsRealmLocalizationLocaleDeleteWithHttpInfo($realm, $locale, $contentType);
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocaleDeleteWithHttpInfo($realm, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocaleDeleteRequest($realm, $locale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleDeleteAsync($realm, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'][0])
    {
        return $this->adminRealmsRealmLocalizationLocaleDeleteAsyncWithHttpInfo($realm, $locale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleDeleteAsyncWithHttpInfo($realm, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmLocalizationLocaleDeleteRequest($realm, $locale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocaleDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocaleDeleteRequest($realm, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocaleDelete'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocaleDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/localization/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale locale (required)
     * @param  bool $use_realm_default_locale_fallback use_realm_default_locale_fallback (optional) (deprecated)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,string>
     */
    public function adminRealmsRealmLocalizationLocaleGet($realm, $locale, $use_realm_default_locale_fallback = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleGet'][0])
    {
        list($response) = $this->adminRealmsRealmLocalizationLocaleGetWithHttpInfo($realm, $locale, $use_realm_default_locale_fallback, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  bool $use_realm_default_locale_fallback (optional) (deprecated)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,string>, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocaleGetWithHttpInfo($realm, $locale, $use_realm_default_locale_fallback = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleGet'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocaleGetRequest($realm, $locale, $use_realm_default_locale_fallback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,string>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string>' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,string>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  bool $use_realm_default_locale_fallback (optional) (deprecated)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleGetAsync($realm, $locale, $use_realm_default_locale_fallback = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleGet'][0])
    {
        return $this->adminRealmsRealmLocalizationLocaleGetAsyncWithHttpInfo($realm, $locale, $use_realm_default_locale_fallback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  bool $use_realm_default_locale_fallback (optional) (deprecated)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleGetAsyncWithHttpInfo($realm, $locale, $use_realm_default_locale_fallback = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleGet'][0])
    {
        $returnType = 'array<string,string>';
        $request = $this->adminRealmsRealmLocalizationLocaleGetRequest($realm, $locale, $use_realm_default_locale_fallback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocaleGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  bool $use_realm_default_locale_fallback (optional) (deprecated)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocaleGetRequest($realm, $locale, $use_realm_default_locale_fallback = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocaleGet'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocaleGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/localization/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_realm_default_locale_fallback,
            'useRealmDefaultLocaleFallback', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key key (required)
     * @param  string $locale locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmLocalizationLocaleKeyDelete($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'][0])
    {
        $this->adminRealmsRealmLocalizationLocaleKeyDeleteWithHttpInfo($realm, $key, $locale, $contentType);
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocaleKeyDeleteWithHttpInfo($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocaleKeyDeleteRequest($realm, $key, $locale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyDeleteAsync($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'][0])
    {
        return $this->adminRealmsRealmLocalizationLocaleKeyDeleteAsyncWithHttpInfo($realm, $key, $locale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyDeleteAsyncWithHttpInfo($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmLocalizationLocaleKeyDeleteRequest($realm, $key, $locale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocaleKeyDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocaleKeyDeleteRequest($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocaleKeyDelete'
            );
        }

        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling adminRealmsRealmLocalizationLocaleKeyDelete'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocaleKeyDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/localization/{locale}/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key key (required)
     * @param  string $locale locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function adminRealmsRealmLocalizationLocaleKeyGet($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'][0])
    {
        list($response) = $this->adminRealmsRealmLocalizationLocaleKeyGetWithHttpInfo($realm, $key, $locale, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocaleKeyGetWithHttpInfo($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocaleKeyGetRequest($realm, $key, $locale, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyGetAsync($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'][0])
    {
        return $this->adminRealmsRealmLocalizationLocaleKeyGetAsyncWithHttpInfo($realm, $key, $locale, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyGetAsyncWithHttpInfo($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'][0])
    {
        $returnType = 'string';
        $request = $this->adminRealmsRealmLocalizationLocaleKeyGetRequest($realm, $key, $locale, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocaleKeyGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocaleKeyGetRequest($realm, $key, $locale, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocaleKeyGet'
            );
        }

        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling adminRealmsRealmLocalizationLocaleKeyGet'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocaleKeyGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/localization/{locale}/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key key (required)
     * @param  string $locale locale (required)
     * @param  string $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmLocalizationLocaleKeyPut($realm, $key, $locale, $body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'][0])
    {
        $this->adminRealmsRealmLocalizationLocaleKeyPutWithHttpInfo($realm, $key, $locale, $body, $contentType);
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocaleKeyPutWithHttpInfo($realm, $key, $locale, $body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocaleKeyPutRequest($realm, $key, $locale, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyPutAsync($realm, $key, $locale, $body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'][0])
    {
        return $this->adminRealmsRealmLocalizationLocaleKeyPutAsyncWithHttpInfo($realm, $key, $locale, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocaleKeyPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocaleKeyPutAsyncWithHttpInfo($realm, $key, $locale, $body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmLocalizationLocaleKeyPutRequest($realm, $key, $locale, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocaleKeyPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $key (required)
     * @param  string $locale (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocaleKeyPutRequest($realm, $key, $locale, $body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocaleKeyPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocaleKeyPut'
            );
        }

        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling adminRealmsRealmLocalizationLocaleKeyPut'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocaleKeyPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/localization/{locale}/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocalePost
     *
     * Import localization from uploaded JSON file
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale locale (required)
     * @param  array<string,string> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocalePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmLocalizationLocalePost($realm, $locale, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocalePost'][0])
    {
        $this->adminRealmsRealmLocalizationLocalePostWithHttpInfo($realm, $locale, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmLocalizationLocalePostWithHttpInfo
     *
     * Import localization from uploaded JSON file
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocalePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLocalizationLocalePostWithHttpInfo($realm, $locale, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocalePost'][0])
    {
        $request = $this->adminRealmsRealmLocalizationLocalePostRequest($realm, $locale, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLocalizationLocalePostAsync
     *
     * Import localization from uploaded JSON file
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocalePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocalePostAsync($realm, $locale, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocalePost'][0])
    {
        return $this->adminRealmsRealmLocalizationLocalePostAsyncWithHttpInfo($realm, $locale, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLocalizationLocalePostAsyncWithHttpInfo
     *
     * Import localization from uploaded JSON file
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocalePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLocalizationLocalePostAsyncWithHttpInfo($realm, $locale, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocalePost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmLocalizationLocalePostRequest($realm, $locale, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLocalizationLocalePost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $locale (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLocalizationLocalePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLocalizationLocalePostRequest($realm, $locale, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmLocalizationLocalePost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLocalizationLocalePost'
            );
        }

        // verify the required parameter 'locale' is set
        if ($locale === null || (is_array($locale) && count($locale) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $locale when calling adminRealmsRealmLocalizationLocalePost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/localization/{locale}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($locale !== null) {
            $resourcePath = str_replace(
                '{' . 'locale' . '}',
                ObjectSerializer::toPathValue($locale),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmLogoutAllPost
     *
     * Removes all user sessions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLogoutAllPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult
     */
    public function adminRealmsRealmLogoutAllPost($realm, string $contentType = self::contentTypes['adminRealmsRealmLogoutAllPost'][0])
    {
        list($response) = $this->adminRealmsRealmLogoutAllPostWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmLogoutAllPostWithHttpInfo
     *
     * Removes all user sessions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLogoutAllPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmLogoutAllPostWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmLogoutAllPost'][0])
    {
        $request = $this->adminRealmsRealmLogoutAllPostRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmLogoutAllPostAsync
     *
     * Removes all user sessions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLogoutAllPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLogoutAllPostAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmLogoutAllPost'][0])
    {
        return $this->adminRealmsRealmLogoutAllPostAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmLogoutAllPostAsyncWithHttpInfo
     *
     * Removes all user sessions.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLogoutAllPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmLogoutAllPostAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmLogoutAllPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
        $request = $this->adminRealmsRealmLogoutAllPostRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmLogoutAllPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmLogoutAllPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmLogoutAllPostRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmLogoutAllPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmLogoutAllPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/logout-all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmPartialExportPost
     *
     * Partial export of existing realm into a JSON file.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $export_clients export_clients (optional)
     * @param  bool $export_groups_and_roles export_groups_and_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialExportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmPartialExportPost($realm, $export_clients = null, $export_groups_and_roles = null, string $contentType = self::contentTypes['adminRealmsRealmPartialExportPost'][0])
    {
        $this->adminRealmsRealmPartialExportPostWithHttpInfo($realm, $export_clients, $export_groups_and_roles, $contentType);
    }

    /**
     * Operation adminRealmsRealmPartialExportPostWithHttpInfo
     *
     * Partial export of existing realm into a JSON file.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $export_clients (optional)
     * @param  bool $export_groups_and_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialExportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmPartialExportPostWithHttpInfo($realm, $export_clients = null, $export_groups_and_roles = null, string $contentType = self::contentTypes['adminRealmsRealmPartialExportPost'][0])
    {
        $request = $this->adminRealmsRealmPartialExportPostRequest($realm, $export_clients, $export_groups_and_roles, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmPartialExportPostAsync
     *
     * Partial export of existing realm into a JSON file.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $export_clients (optional)
     * @param  bool $export_groups_and_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPartialExportPostAsync($realm, $export_clients = null, $export_groups_and_roles = null, string $contentType = self::contentTypes['adminRealmsRealmPartialExportPost'][0])
    {
        return $this->adminRealmsRealmPartialExportPostAsyncWithHttpInfo($realm, $export_clients, $export_groups_and_roles, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmPartialExportPostAsyncWithHttpInfo
     *
     * Partial export of existing realm into a JSON file.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $export_clients (optional)
     * @param  bool $export_groups_and_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPartialExportPostAsyncWithHttpInfo($realm, $export_clients = null, $export_groups_and_roles = null, string $contentType = self::contentTypes['adminRealmsRealmPartialExportPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmPartialExportPostRequest($realm, $export_clients, $export_groups_and_roles, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmPartialExportPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  bool $export_clients (optional)
     * @param  bool $export_groups_and_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmPartialExportPostRequest($realm, $export_clients = null, $export_groups_and_roles = null, string $contentType = self::contentTypes['adminRealmsRealmPartialExportPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmPartialExportPost'
            );
        }




        $resourcePath = '/admin/realms/{realm}/partial-export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_clients,
            'exportClients', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $export_groups_and_roles,
            'exportGroupsAndRoles', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmPartialImportPost
     *
     * Partial import from a JSON file to an existing realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialImportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmPartialImportPost($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmPartialImportPost'][0])
    {
        $this->adminRealmsRealmPartialImportPostWithHttpInfo($realm, $body, $contentType);
    }

    /**
     * Operation adminRealmsRealmPartialImportPostWithHttpInfo
     *
     * Partial import from a JSON file to an existing realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialImportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmPartialImportPostWithHttpInfo($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmPartialImportPost'][0])
    {
        $request = $this->adminRealmsRealmPartialImportPostRequest($realm, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmPartialImportPostAsync
     *
     * Partial import from a JSON file to an existing realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPartialImportPostAsync($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmPartialImportPost'][0])
    {
        return $this->adminRealmsRealmPartialImportPostAsyncWithHttpInfo($realm, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmPartialImportPostAsyncWithHttpInfo
     *
     * Partial import from a JSON file to an existing realm.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPartialImportPostAsyncWithHttpInfo($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmPartialImportPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmPartialImportPostRequest($realm, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmPartialImportPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPartialImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmPartialImportPostRequest($realm, $body = null, string $contentType = self::contentTypes['adminRealmsRealmPartialImportPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmPartialImportPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/partialImport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmPushRevocationPost
     *
     * Push the realm&#39;s revocation policy to any client that has an admin url associated with it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult
     */
    public function adminRealmsRealmPushRevocationPost($realm, string $contentType = self::contentTypes['adminRealmsRealmPushRevocationPost'][0])
    {
        list($response) = $this->adminRealmsRealmPushRevocationPostWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmPushRevocationPostWithHttpInfo
     *
     * Push the realm&#39;s revocation policy to any client that has an admin url associated with it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmPushRevocationPostWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmPushRevocationPost'][0])
    {
        $request = $this->adminRealmsRealmPushRevocationPostRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmPushRevocationPostAsync
     *
     * Push the realm&#39;s revocation policy to any client that has an admin url associated with it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPushRevocationPostAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmPushRevocationPost'][0])
    {
        return $this->adminRealmsRealmPushRevocationPostAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmPushRevocationPostAsyncWithHttpInfo
     *
     * Push the realm&#39;s revocation policy to any client that has an admin url associated with it.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPushRevocationPostAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmPushRevocationPost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\GlobalRequestResult';
        $request = $this->adminRealmsRealmPushRevocationPostRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmPushRevocationPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPushRevocationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmPushRevocationPostRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmPushRevocationPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmPushRevocationPost'
            );
        }


        $resourcePath = '/admin/realms/{realm}/push-revocation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmPut
     *
     * Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation $realm_representation realm_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmPut($realm, $realm_representation = null, string $contentType = self::contentTypes['adminRealmsRealmPut'][0])
    {
        $this->adminRealmsRealmPutWithHttpInfo($realm, $realm_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmPutWithHttpInfo
     *
     * Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation $realm_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmPutWithHttpInfo($realm, $realm_representation = null, string $contentType = self::contentTypes['adminRealmsRealmPut'][0])
    {
        $request = $this->adminRealmsRealmPutRequest($realm, $realm_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmPutAsync
     *
     * Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation $realm_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPutAsync($realm, $realm_representation = null, string $contentType = self::contentTypes['adminRealmsRealmPut'][0])
    {
        return $this->adminRealmsRealmPutAsyncWithHttpInfo($realm, $realm_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmPutAsyncWithHttpInfo
     *
     * Update the top-level information of the realm Any user, roles or client information in the representation will be ignored.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation $realm_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmPutAsyncWithHttpInfo($realm, $realm_representation = null, string $contentType = self::contentTypes['adminRealmsRealmPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmPutRequest($realm, $realm_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\RealmRepresentation $realm_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmPutRequest($realm, $realm_representation = null, string $contentType = self::contentTypes['adminRealmsRealmPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($realm_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($realm_representation));
            } else {
                $httpBody = $realm_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmSessionsSessionDelete
     *
     * Remove a specific user session.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $session session (required)
     * @param  bool $is_offline is_offline (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmSessionsSessionDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmSessionsSessionDelete($realm, $session, $is_offline = false, string $contentType = self::contentTypes['adminRealmsRealmSessionsSessionDelete'][0])
    {
        $this->adminRealmsRealmSessionsSessionDeleteWithHttpInfo($realm, $session, $is_offline, $contentType);
    }

    /**
     * Operation adminRealmsRealmSessionsSessionDeleteWithHttpInfo
     *
     * Remove a specific user session.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $session (required)
     * @param  bool $is_offline (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmSessionsSessionDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmSessionsSessionDeleteWithHttpInfo($realm, $session, $is_offline = false, string $contentType = self::contentTypes['adminRealmsRealmSessionsSessionDelete'][0])
    {
        $request = $this->adminRealmsRealmSessionsSessionDeleteRequest($realm, $session, $is_offline, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmSessionsSessionDeleteAsync
     *
     * Remove a specific user session.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $session (required)
     * @param  bool $is_offline (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmSessionsSessionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmSessionsSessionDeleteAsync($realm, $session, $is_offline = false, string $contentType = self::contentTypes['adminRealmsRealmSessionsSessionDelete'][0])
    {
        return $this->adminRealmsRealmSessionsSessionDeleteAsyncWithHttpInfo($realm, $session, $is_offline, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmSessionsSessionDeleteAsyncWithHttpInfo
     *
     * Remove a specific user session.
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $session (required)
     * @param  bool $is_offline (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmSessionsSessionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmSessionsSessionDeleteAsyncWithHttpInfo($realm, $session, $is_offline = false, string $contentType = self::contentTypes['adminRealmsRealmSessionsSessionDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmSessionsSessionDeleteRequest($realm, $session, $is_offline, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmSessionsSessionDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $session (required)
     * @param  bool $is_offline (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmSessionsSessionDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmSessionsSessionDeleteRequest($realm, $session, $is_offline = false, string $contentType = self::contentTypes['adminRealmsRealmSessionsSessionDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmSessionsSessionDelete'
            );
        }

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling adminRealmsRealmSessionsSessionDelete'
            );
        }



        $resourcePath = '/admin/realms/{realm}/sessions/{session}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_offline,
            'isOffline', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmTestSMTPConnectionPost
     *
     * Test SMTP connection with current logged in user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function adminRealmsRealmTestSMTPConnectionPost($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'][0])
    {
        $this->adminRealmsRealmTestSMTPConnectionPostWithHttpInfo($realm, $request_body, $contentType);
    }

    /**
     * Operation adminRealmsRealmTestSMTPConnectionPostWithHttpInfo
     *
     * Test SMTP connection with current logged in user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function adminRealmsRealmTestSMTPConnectionPostWithHttpInfo($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'][0])
    {
        $request = $this->adminRealmsRealmTestSMTPConnectionPostRequest($realm, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmTestSMTPConnectionPostAsync
     *
     * Test SMTP connection with current logged in user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmTestSMTPConnectionPostAsync($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'][0])
    {
        return $this->adminRealmsRealmTestSMTPConnectionPostAsyncWithHttpInfo($realm, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmTestSMTPConnectionPostAsyncWithHttpInfo
     *
     * Test SMTP connection with current logged in user
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function adminRealmsRealmTestSMTPConnectionPostAsyncWithHttpInfo($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmTestSMTPConnectionPostRequest($realm, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmTestSMTPConnectionPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  array<string,string> $request_body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function adminRealmsRealmTestSMTPConnectionPostRequest($realm, $request_body = null, string $contentType = self::contentTypes['adminRealmsRealmTestSMTPConnectionPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmTestSMTPConnectionPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/testSMTPConnection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmUsersManagementPermissionsGet($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmUsersManagementPermissionsGetWithHttpInfo($realm, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersManagementPermissionsGetWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'][0])
    {
        $request = $this->adminRealmsRealmUsersManagementPermissionsGetRequest($realm, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersManagementPermissionsGetAsync($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'][0])
    {
        return $this->adminRealmsRealmUsersManagementPermissionsGetAsyncWithHttpInfo($realm, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersManagementPermissionsGetAsyncWithHttpInfo($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmUsersManagementPermissionsGetRequest($realm, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersManagementPermissionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersManagementPermissionsGetRequest($realm, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersManagementPermissionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/users-management-permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference
     */
    public function adminRealmsRealmUsersManagementPermissionsPut($realm, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'][0])
    {
        list($response) = $this->adminRealmsRealmUsersManagementPermissionsPutWithHttpInfo($realm, $management_permission_reference, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmUsersManagementPermissionsPutWithHttpInfo($realm, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'][0])
    {
        $request = $this->adminRealmsRealmUsersManagementPermissionsPutRequest($realm, $management_permission_reference, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersManagementPermissionsPutAsync($realm, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'][0])
    {
        return $this->adminRealmsRealmUsersManagementPermissionsPutAsyncWithHttpInfo($realm, $management_permission_reference, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmUsersManagementPermissionsPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmUsersManagementPermissionsPutAsyncWithHttpInfo($realm, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference';
        $request = $this->adminRealmsRealmUsersManagementPermissionsPutRequest($realm, $management_permission_reference, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmUsersManagementPermissionsPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ManagementPermissionReference $management_permission_reference (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmUsersManagementPermissionsPutRequest($realm, $management_permission_reference = null, string $contentType = self::contentTypes['adminRealmsRealmUsersManagementPermissionsPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmUsersManagementPermissionsPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/users-management-permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($management_permission_reference)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($management_permission_reference));
            } else {
                $httpBody = $management_permission_reference;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
