<?php
/**
 * DefaultApi
 * PHP version 7.4
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Keycloak Admin REST API
 *
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebMI\KeycloakApiClient\KeycloakApi\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebMI\KeycloakApiClient\KeycloakApi\ApiException;
use WebMI\KeycloakApiClient\KeycloakApi\Configuration;
use WebMI\KeycloakApiClient\KeycloakApi\HeaderSelector;
use WebMI\KeycloakApiClient\KeycloakApi\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  WebMI\KeycloakApiClient\KeycloakApi
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'adminRealmsRealmClientsClientUuidAuthzResourceServerGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet' => [
            'application/json',
        ],
        'adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostWithHttpInfo($realm, $client_uuid, $resource_server_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostWithHttpInfo($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostRequest($realm, $client_uuid, $resource_server_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostAsync($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostAsyncWithHttpInfo($realm, $client_uuid, $resource_server_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostAsyncWithHttpInfo($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostRequest($realm, $client_uuid, $resource_server_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerImportPostRequest($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerImportPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_server_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_server_representation));
            } else {
                $httpBody = $resource_server_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostWithHttpInfo($realm, $client_uuid, $policy_evaluation_request, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostWithHttpInfo($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostAsync($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostAsyncWithHttpInfo($realm, $client_uuid, $policy_evaluation_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostAsyncWithHttpInfo($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionEvaluatePost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/permission/evaluate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($policy_evaluation_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($policy_evaluation_request));
            } else {
                $httpBody = $policy_evaluation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields fields (optional)
     * @param  int $first first (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  bool $permission permission (optional)
     * @param  string $policy_id policy_id (optional)
     * @param  string $resource resource (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetWithHttpInfo($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetWithHttpInfo($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetRequest($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetAsync($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetAsyncWithHttpInfo($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetAsyncWithHttpInfo($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetRequest($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGetRequest($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionGet'
            );
        }












        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/permission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission,
            'permission', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $policy_id,
            'policyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource,
            'resource', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostWithHttpInfo($realm, $client_uuid, $body, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostWithHttpInfo($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostRequest($realm, $client_uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostAsync($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostAsyncWithHttpInfo($realm, $client_uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostAsyncWithHttpInfo($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostRequest($realm, $client_uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPostRequest($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/permission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/permission/providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields fields (optional)
     * @param  string $name name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetWithHttpInfo($realm, $client_uuid, $fields, $name, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetWithHttpInfo($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetRequest($realm, $client_uuid, $fields, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetAsync($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetAsyncWithHttpInfo($realm, $client_uuid, $fields, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetAsyncWithHttpInfo($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetRequest($realm, $client_uuid, $fields, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGetRequest($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPermissionSearchGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/permission/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostWithHttpInfo($realm, $client_uuid, $policy_evaluation_request, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostWithHttpInfo($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostAsync($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostAsyncWithHttpInfo($realm, $client_uuid, $policy_evaluation_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostAsyncWithHttpInfo($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationResponse';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyEvaluationRequest $policy_evaluation_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePostRequest($realm, $client_uuid, $policy_evaluation_request = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyEvaluatePost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/policy/evaluate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($policy_evaluation_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($policy_evaluation_request));
            } else {
                $httpBody = $policy_evaluation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields fields (optional)
     * @param  int $first first (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  bool $permission permission (optional)
     * @param  string $policy_id policy_id (optional)
     * @param  string $resource resource (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetWithHttpInfo($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetWithHttpInfo($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetRequest($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetAsync($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetAsyncWithHttpInfo($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetAsyncWithHttpInfo($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetRequest($realm, $client_uuid, $fields, $first, $max, $name, $owner, $permission, $policy_id, $resource, $scope, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  bool $permission (optional)
     * @param  string $policy_id (optional)
     * @param  string $resource (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGetRequest($realm, $client_uuid, $fields = null, $first = null, $max = null, $name = null, $owner = null, $permission = null, $policy_id = null, $resource = null, $scope = null, $type = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyGet'
            );
        }












        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $permission,
            'permission', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $policy_id,
            'policyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resource,
            'resource', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostWithHttpInfo($realm, $client_uuid, $body, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostWithHttpInfo($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostRequest($realm, $client_uuid, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostAsync($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostAsyncWithHttpInfo($realm, $client_uuid, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostAsyncWithHttpInfo($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostRequest($realm, $client_uuid, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPostRequest($realm, $client_uuid, $body = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyPost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyProviderRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicyProvidersGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/policy/providers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields fields (optional)
     * @param  string $name name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetWithHttpInfo($realm, $client_uuid, $fields, $name, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetWithHttpInfo($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetRequest($realm, $client_uuid, $fields, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetAsync($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetAsyncWithHttpInfo($realm, $client_uuid, $fields, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetAsyncWithHttpInfo($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\AbstractPolicyRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetRequest($realm, $client_uuid, $fields, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $fields (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGetRequest($realm, $client_uuid, $fields = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPolicySearchGet'
            );
        }




        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/policy/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fields,
            'fields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPut($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPutWithHttpInfo($realm, $client_uuid, $resource_server_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPutWithHttpInfo($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPutRequest($realm, $client_uuid, $resource_server_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPutAsync($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPutAsyncWithHttpInfo($realm, $client_uuid, $resource_server_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPutAsyncWithHttpInfo($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerPutRequest($realm, $client_uuid, $resource_server_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation $resource_server_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerPutRequest($realm, $client_uuid, $resource_server_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_server_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_server_representation));
            } else {
                $httpBody = $resource_server_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetAsync($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetAsyncWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetAsyncWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGetRequest($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostAsync($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostAsyncWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostAsyncWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePostRequest($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourcePost'
            );
        }














        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_representation));
            } else {
                $httpBody = $resource_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGetRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdAttributesGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}/attributes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDeleteRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdDelete'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGetRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGetRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPermissionsGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $resource_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation $resource_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPutRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, $resource_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdPut'
            );
        }














        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_representation));
            } else {
                $httpBody = $resource_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id resource_id (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetAsync($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetAsyncWithHttpInfo($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetRequest($realm, $client_uuid, $resource_id, $_id, $deep, $exact_name, $first, $matching_uri, $max, $name, $owner, $scope, $type, $uri, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $resource_id (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGetRequest($realm, $client_uuid, $resource_id, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $name = null, $owner = null, $scope = null, $type = null, $uri = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'
            );
        }

        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceResourceIdScopesGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/{resource-id}/scopes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource-id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id _id (optional)
     * @param  bool $deep deep (optional)
     * @param  bool $exact_name exact_name (optional)
     * @param  int $first first (optional)
     * @param  bool $matching_uri matching_uri (optional)
     * @param  int $max max (optional)
     * @param  string $owner owner (optional)
     * @param  string $scope scope (optional)
     * @param  string $type type (optional)
     * @param  string $uri uri (optional)
     * @param  string $name name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $owner = null, $scope = null, $type = null, $uri = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $owner, $scope, $type, $uri, $name, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $owner = null, $scope = null, $type = null, $uri = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $owner, $scope, $type, $uri, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetAsync($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $owner = null, $scope = null, $type = null, $uri = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetAsyncWithHttpInfo($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $owner, $scope, $type, $uri, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetAsyncWithHttpInfo($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $owner = null, $scope = null, $type = null, $uri = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetRequest($realm, $client_uuid, $_id, $deep, $exact_name, $first, $matching_uri, $max, $owner, $scope, $type, $uri, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $_id (optional)
     * @param  bool $deep (optional)
     * @param  bool $exact_name (optional)
     * @param  int $first (optional)
     * @param  bool $matching_uri (optional)
     * @param  int $max (optional)
     * @param  string $owner (optional)
     * @param  string $scope (optional)
     * @param  string $type (optional)
     * @param  string $uri (optional)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGetRequest($realm, $client_uuid, $_id = null, $deep = null, $exact_name = null, $first = null, $matching_uri = null, $max = null, $owner = null, $scope = null, $type = null, $uri = null, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerResourceSearchGet'
            );
        }













        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/resource/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $_id,
            '_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deep,
            'deep', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exact_name,
            'exactName', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $matching_uri,
            'matchingUri', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $owner,
            'owner', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope,
            'scope', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uri,
            'uri', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first first (optional)
     * @param  int $max max (optional)
     * @param  string $name name (optional)
     * @param  string $scope_id scope_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet($realm, $client_uuid, $first = null, $max = null, $name = null, $scope_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetWithHttpInfo($realm, $client_uuid, $first, $max, $name, $scope_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $scope_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetWithHttpInfo($realm, $client_uuid, $first = null, $max = null, $name = null, $scope_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetRequest($realm, $client_uuid, $first, $max, $name, $scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $scope_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetAsync($realm, $client_uuid, $first = null, $max = null, $name = null, $scope_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetAsyncWithHttpInfo($realm, $client_uuid, $first, $max, $name, $scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $scope_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetAsyncWithHttpInfo($realm, $client_uuid, $first = null, $max = null, $name = null, $scope_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetRequest($realm, $client_uuid, $first, $max, $name, $scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  int $first (optional)
     * @param  int $max (optional)
     * @param  string $name (optional)
     * @param  string $scope_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGetRequest($realm, $client_uuid, $first = null, $max = null, $name = null, $scope_id = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeGet'
            );
        }






        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first,
            'first', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max,
            'max', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scope_id,
            'scopeId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost($realm, $client_uuid, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostWithHttpInfo($realm, $client_uuid, $scope_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostWithHttpInfo($realm, $client_uuid, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostRequest($realm, $client_uuid, $scope_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostAsync($realm, $client_uuid, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostAsyncWithHttpInfo($realm, $client_uuid, $scope_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostAsyncWithHttpInfo($realm, $client_uuid, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostRequest($realm, $client_uuid, $scope_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopePostRequest($realm, $client_uuid, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopePost'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($scope_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($scope_representation));
            } else {
                $httpBody = $scope_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteWithHttpInfo($realm, $client_uuid, $scope_id, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteRequest($realm, $client_uuid, $scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteAsync($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteAsyncWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteRequest($realm, $client_uuid, $scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDeleteRequest($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'
            );
        }

        // verify the required parameter 'scope_id' is set
        if ($scope_id === null || (is_array($scope_id) && count($scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scope_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdDelete'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/{scope-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scope-id' . '}',
                ObjectSerializer::toPathValue($scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetWithHttpInfo($realm, $client_uuid, $scope_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetRequest($realm, $client_uuid, $scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetAsync($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetRequest($realm, $client_uuid, $scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGetRequest($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'
            );
        }

        // verify the required parameter 'scope_id' is set
        if ($scope_id === null || (is_array($scope_id) && count($scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scope_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/{scope-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scope-id' . '}',
                ObjectSerializer::toPathValue($scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetWithHttpInfo($realm, $client_uuid, $scope_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetRequest($realm, $client_uuid, $scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetAsync($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\PolicyRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetRequest($realm, $client_uuid, $scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGetRequest($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'
            );
        }

        // verify the required parameter 'scope_id' is set
        if ($scope_id === null || (is_array($scope_id) && count($scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scope_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPermissionsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/{scope-id}/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scope-id' . '}',
                ObjectSerializer::toPathValue($scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id scope_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut($realm, $client_uuid, $scope_id, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'][0])
    {
        $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutWithHttpInfo($realm, $client_uuid, $scope_id, $scope_representation, $contentType);
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutWithHttpInfo($realm, $client_uuid, $scope_id, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutRequest($realm, $client_uuid, $scope_id, $scope_representation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutAsync($realm, $client_uuid, $scope_id, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $scope_representation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'][0])
    {
        $returnType = '';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutRequest($realm, $client_uuid, $scope_id, $scope_representation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation $scope_representation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPutRequest($realm, $client_uuid, $scope_id, $scope_representation = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'
            );
        }

        // verify the required parameter 'scope_id' is set
        if ($scope_id === null || (is_array($scope_id) && count($scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scope_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdPut'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/{scope-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scope-id' . '}',
                ObjectSerializer::toPathValue($scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($scope_representation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($scope_representation));
            } else {
                $httpBody = $scope_representation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetWithHttpInfo($realm, $client_uuid, $scope_id, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetRequest($realm, $client_uuid, $scope_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetAsync($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetAsyncWithHttpInfo($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetRequest($realm, $client_uuid, $scope_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $scope_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGetRequest($realm, $client_uuid, $scope_id, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'
            );
        }

        // verify the required parameter 'scope_id' is set
        if ($scope_id === null || (is_array($scope_id) && count($scope_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scope_id when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeScopeIdResourcesGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/{scope-id}/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }
        // path params
        if ($scope_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scope-id' . '}',
                ObjectSerializer::toPathValue($scope_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $name name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet($realm, $client_uuid, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetWithHttpInfo($realm, $client_uuid, $name, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetWithHttpInfo($realm, $client_uuid, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetRequest($realm, $client_uuid, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetAsync($realm, $client_uuid, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetAsyncWithHttpInfo($realm, $client_uuid, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetAsyncWithHttpInfo($realm, $client_uuid, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ScopeRepresentation[]';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetRequest($realm, $client_uuid, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGetRequest($realm, $client_uuid, $name = null, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerScopeSearchGet'
            );
        }



        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/scope/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'][0])
    {
        list($response) = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetWithHttpInfo($realm, $client_uuid, $contentType);
        return $response;
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'] to see the possible values for this operation
     *
     * @throws \WebMI\KeycloakApiClient\KeycloakApi\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'][0])
    {
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetRequest($realm, $client_uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetAsync
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetAsync($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'][0])
    {
        return $this->adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetAsyncWithHttpInfo($realm, $client_uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetAsyncWithHttpInfo
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetAsyncWithHttpInfo($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'][0])
    {
        $returnType = '\WebMI\KeycloakApiClient\KeycloakApi\Model\ResourceServerRepresentation';
        $request = $this->adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetRequest($realm, $client_uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'
     *
     * @param  string $realm realm name (not id!) (required)
     * @param  string $client_uuid id of client (not client-id!) (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGetRequest($realm, $client_uuid, string $contentType = self::contentTypes['adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'][0])
    {

        // verify the required parameter 'realm' is set
        if ($realm === null || (is_array($realm) && count($realm) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $realm when calling adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'
            );
        }

        // verify the required parameter 'client_uuid' is set
        if ($client_uuid === null || (is_array($client_uuid) && count($client_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_uuid when calling adminRealmsRealmClientsClientUuidAuthzResourceServerSettingsGet'
            );
        }


        $resourcePath = '/admin/realms/{realm}/clients/{client-uuid}/authz/resource-server/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($realm !== null) {
            $resourcePath = str_replace(
                '{' . 'realm' . '}',
                ObjectSerializer::toPathValue($realm),
                $resourcePath
            );
        }
        // path params
        if ($client_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'client-uuid' . '}',
                ObjectSerializer::toPathValue($client_uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
